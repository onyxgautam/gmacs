* Starting Up
** Fixing the UI
:PROPERTIES:
:header-args: :tangle no
:END:
Emacs ships with a set of pretty strange defaults. The UI is the first thing we
see when we open Emacs, so it better not look ugly. We're going to configure
part of the UI outside Emacs entirely, by editing the =~/.Xresources=.

This kills the ugly parts of the UI before they are born. This is slightly
faster than disabling them within Emacs, but it offers less flexibility. For
example, if Emacs fails to start up properly, you are possibly left staring at a
chimera of an editor, with default font colours but themed background colours.
Because the font is about the same shade as the background, this makes for some
very fun times debugging.

After editing =.Xresources=, remember to reload it with =xrdb merge ~/.Xresources=.
*** Bars
I never use menu bars, tool bars, or scroll bars in Emacs.
#+BEGIN_SRC conf
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
#+END_SRC
*** Cursor Blinking
In earlier versions of Emacs, the cursor would blink ten or so times, then
suddenly stop. This got annoying quickly.
#+BEGIN_SRC conf
Emacs.cursorBlink: off
#+END_SRC
*** Background Colour
Before a theme is initialized, the default background colour that Emacs displays
is white. However, my default theme is a dark theme (Solarized Dark). If I were
to change the background colour after Emacs starts, the screen would flash as it
changes colour. And so I set the default background and foreground colour to be
that of Solarized Dark.
#+BEGIN_SRC conf
Emacs.background: #002b36
Emacs.foreground: #839496
#+END_SRC
The last thing left that is visible throughout startup is the modeline. It
took a bit of Internet sleuthing to figure out how to set this, but here it is.
#+BEGIN_SRC conf
Emacs.mode-line.attributeForeground: #93a1a1
Emacs.mode-line.attributeBackground: #002b36
Emacs.mode-line.attributeBox: (:line-width 1 :color "#073642")
#+END_SRC
*** Default Font
I often experiment with fonts during an Emacs session, so I set up an easy way
to change that [[*Font Face][here]]. On startup, though, I want something neutral, so I go with
Hack.
#+BEGIN_SRC conf
Emacs.font: Hack-10
#+END_SRC
** Early Init
Here's some cutting edge technology. Emacs 27 introduced =early-init.el=, which
is run before =init.el=, before package initialization.

Package initialization occurs automatically, before =user-init-file= is loaded,
but after =early-init-file=. As we'll see later, we can handle package
initialization ourselves, so there's no need for Emacs to do it first.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
(setq gc-cons-threshold most-positive-fixnum)
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+END_SRC
** =init.el=
The main entry point into GMACS. First, we remove some features that would make
startup take longer and aren't that useful.
#+BEGIN_SRC emacs-lisp :tangle init.el
(advice-add #'display-startup-echo-area-message :override #'ignore)
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
#+END_SRC
We tangle and load the GMACS literate config file (you're reading it!) written
in Org Mode.
#+BEGIN_SRC emacs-lisp :tangle init.el
(advice-add #'display-startup-echo-area-message :override #'ignore)
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)

(let ((file-name-handler-alist nil)
      (orgfile (expand-file-name "gmacs.org" user-emacs-directory))
      (elfile (expand-file-name "gmacs.el" user-emacs-directory)))
  (if (or (not (file-exists-p elfile))
          (file-newer-than-file-p orgfile elfile))
      (progn
        ;; (require 'org)
        (org-babel-load-file orgfile))
    (load-file elfile)))

(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file) (load custom-file))

(let ((personalfile (expand-file-name "personal.el" user-emacs-directory)))
  (when (file-exists-p personalfile)
    (load-file personalfile)))
#+END_SRC
** Initialization Settings
Enable lexical binding.
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC
Always load up a server when opening Emacs, unless one is already running.
#+BEGIN_SRC emacs-lisp
  (defun server-already-running-p ()
    "Is Emacs already running?
    Gets name based on server-force-delete."
    (let ((file (expand-file-name
		 server-name
		 (if server-use-tcp
		     server-auth-dir
		   server-socket-dir))))
      (file-exists-p file)))

(defun server-shunt ()
    "Shunts to emacsclient"
    (let ((args (append '("emacsclient" "-a" "\"\"" "-c" "-n")
			(cdr command-line-args))))
      (shell-command (substring (format "%S" args) 1 -1))
      (kill-emacs)))

  (unless (featurep 'server)
    (unless (boundp 'server-process)
      (require 'server)
      (if (server-already-running-p) (server-shunt) (server-start))))
#+END_SRC
We increase these so that we don't exceed recursion limits unless there is some
kind of infinite loop.
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000
      max-specpdl-size 10000)
#+END_SRC
Now we prevent loading double buffers, which reduces stuttering.
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC
Silence some common warnings from the byte-compiler.
#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
Generate native compiled files whenever Emacs loads a =.elc= file.
#+BEGIN_SRC emacs-lisp
(setq comp-deferred-compilation t)
#+END_SRC
Let the user know how quickly GMACS started.
#+BEGIN_SRC emacs-lisp
(defun og/startup-time ()
  (interactive)
  (message "GMACS ready in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'after-init-hook #'og/startup-time)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
      (lambda ()
        "Restore defalut values after init."
        (setq file-name-handler-alist default-file-name-handler-alist)
        (setq gc-cons-threshold (* 50 1024 1024))))
#+END_SRC
** Directories and File Locations
We define a few custom directories to satisfy my own wishes for how things
should be named and to speed up the package initialization process by doing it
ourselves, rather than relying on =package-initialize=. Note that the whole thing
is wrapped in a byte-compile block.

We make the directories if they don't exist by iterating over a list. This
method makes it easy for to extend to more directories if needed.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar gmacs-packages-dir (concat user-emacs-directory "packages/")
    "Where package.el and elpa plugins (and their caches) are stored.")

  (defvar gmacs-custom-dir (concat user-emacs-directory "elisp/")
    "Where custom lisp files are stored")

  (defvar gmacs-cache-dir (concat user-emacs-directory "cache/")
    "Where temporary files that could be deleted without anything
    terrible happening are stored.")

  (dolist (dir (list gmacs-packages-dir
                     gmacs-custom-dir
                     gmacs-cache-dir))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file) (load custom-file))
#+END_SRC
Make a variable for personal settings.
#+BEGIN_SRC emacs-lisp
(defvar og/user nil)
#+END_SRC
** Setup Packages
We're going to use a custom package directory, so we need to trick Emacs into
thinking it has initialized packages by setting =package--init-file-ensured= to =t=.
Also, we don't enable packages at startup, because we will let =use-package=
intelligently defer and handle package loading.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-prefer-newer t
        package-user-dir gmacs-packages-dir
        package--init-file-ensured t
        package-enable-at-startup nil))
#+END_SRC
We set the =load-path= ourselves. This will be faster than letting
=package-intialize= handle it, because we only add directories we know are from
packages. This way, we don't need to search all third party paths every time we
require a file. We'll also store custom or third-party Emacs Lisp files in
=gmacs-custom-dir=, so we add that to the =load-path=.
#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
  (add-to-list 'load-path gmacs-custom-dir))
#+END_SRC
Our next step is to load =package.el=. We add our package repositories "melpa" and
"gnu," because Emacs' default list of packages is so conservative. Then we need
to initialize the packages and make sure that =use-package= is installed if its
missing. Finally, we tell =use-package= to always install missing packages.
Otherwise, an error would be thrown when a package is missing.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref pack-arch
(setq package-archives
  	  '(("melpa" . "https://melpa.org/packages/")
  	    ("gnu" . "https://elpa.gnu.org/packages/")
  	    ("org" . "http://orgmode.org/elpa/")))
#+END_SRC
Note that this whole process is only run when the file is byte-compiled. This
means that by the time the code is actually evaluated, the =use-package= macro has
been expanded, so the package is not needed anymore. As such, we can do all the
expensive and time-consuming work of getting the packages ready before Emacs has
even started, during byte-compilation. If this config has not been manually
byte-compiled, Emacs will initialize packages on startup as usual.
#+BEGIN_SRC emacs-lisp :noweb no-export
(eval-when-compile
  (require 'package)
  <<pack-arch>>
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package))
#+END_SRC
Get =use-package= to always defer loading packages until they are actually needed.
This reduces startup time significantly. We're doing this now, before
=use-package= is even loaded, because otherwise it won't help us when the code
that loads =use-package= is evaluated upon byte-compilation.
#+BEGIN_SRc emacs-lisp
(setq use-package-always-defer t
      use-package-verbose t
      use-package-always-ensure t)
#+END_SRC
We also require =diminish= and =bind= because I often use these keywords within
=use-package= declarations.
#+BEGIN_SRC emacs-lisp
(use-package bind-key)
(use-package diminish)
#+END_SRC
*** Common Libraries
We load packages that I use throughout my configuration.
#+BEGIN_SRC emacs-lisp
(use-package async :commands (async-start))
#+END_SRC
* General Configuration
** Macros
Elisp macros. =after!= and =lambda!= are from the popular DOOM! Emacs
configuration. The documentation on these will be sparse, because the docstrings
do an excellent job of explaining what's going on.
*** after!
#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
*** lambda!
#+BEGIN_SRC emacs-lisp
(defmacro lambda! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))
#+END_SRC
*** Conditional Keybindings
Obtained from [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][Endless Parentheses]].
#+BEGIN_SRC emacs-lisp
(defmacro define-conditional-key (keymap key def &rest body)
  "In KEYMAP, define key sequence KEY as DEF conditionally.
This is like `define-key', except the definition
\"disappears\" whenever BODY evaluates to nil."
  (declare (indent 3)
           (debug (form form form &rest sexp)))
  `(define-key ,keymap ,key
     '(menu-item
       ,(format "maybe-%s" (or (car (cdr-safe def)) def))
       nil
       :filter (lambda (&optional _)
                 (when ,(macroexp-progn body)
                   ,def)))))
#+END_SRC
** User Interface
Show off the title.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "GMACS")
#+END_SRC
*** Cursor
I prefer a box cursor to a bar cursor. Setting =x-stretch-cursor= means that this
bar will stretch to the full width of the character it is on. For example, on a
tab (evil tabs!), the cursor will look as wide as a tab.
#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (setq-default cursor-type 'box))
(setq x-stretch-cursor t)
#+END_SRC
*** Bells
Visual, not audible bells.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Modeline
The =line-number-mode= displays the current line number in the modeline, except
when there is a line Emacs decides is too long. In that case, all you see in the
modeline is =??=. See [[https://emacs.stackexchange.com/questions/3824/what-piece-of-code-in-emacs-makes-line-number-mode-print-as-line-number-i][this question]] on Emacs SE for a workaround.
#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC
Given that we're showing the line number in the modeline, it's often nice to
also have the column number.
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC
*** Scrolling
There are two types of scrolling in Emacs: keyboard scrolling and mouse
scrolling. Both of them are quite jarring out of the box and make the screen
lurch around. Let's fix keyboard scrolling.
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+END_SRC
And make mouse scrolling smoother.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed t) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse t) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-margin 3) ;; give the cursor some buffer room before scrolling window
#+END_SRC
*** Theme
I use the popular Solarized Light/Dark themes.
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :demand t
  :config (load-theme 'solarized-dark))
#+END_SRC
I switch between the light and dark variants depending on my surroundings. If I
am in a brightly lit room, I prefer to use the light theme, because the dark
theme allows too much screen glare. At night (really, at most times, but in
particular at night) I prefer the dark theme, which, unsurprisingly, spits less
light into my eyes.

The way I switch themes is, admittedly, somewhat hacky. I set a boolean (by
default true) that is true if the active theme is dark, false if light. What can
I say? I prefer the dark side. Then my switch function toggles that value and
changes the theme and the corresponding colours for =pdf-view-mode=. I like to
view my PDFs not in black and white, but in my theme's colours. To make sure
everything looks right, including the colours in PDFs and the asterisks
for headlines in Org Mode (I hide them with =org-bullets-mode= but one of them
comes back when I switch themes, for some reason), I refresh all open buffers.
#+BEGIN_SRC emacs-lisp
(defvar og/theme 'dark)
(defun og/switch-theme ()
  (interactive)
  (if (eq og/theme 'dark)
      (progn
        (load-theme 'solarized-light)
        (after! pdf-tools (setq pdf-view-midnight-colors '("#839496" . "#fdf6e3")))
        (setq og/theme 'light))
    (load-theme 'solarized-dark)
    (setq pdf-view-midnight-colors '("#839496" . "#002b36"))
    (setq og/theme 'dark))
  (modi/revert-buffers))
#+END_SRC
**** Font Face
I change my fonts a lot, so I made it easier to set a font.
#+BEGIN_SRC emacs-lisp
(defun og/switch-font ()
  (interactive)
  (let ((font (ivy-completing-read "Choose a font: "
                                   (delete-dups (font-family-list)))))
    (set-face-attribute 'default nil :font font)))
#+END_SRC
I also like using Palatino here.
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(variable-pitch ((t (:family "Source Sans Pro" :height 115)))))
#+END_SRC
I have experienced problems with certain math characters being displayed with a
font from the TeX Gyre family, which causes the line width to be very high. I
set the default font for characters in the "Mathematical Alphanumeric Symbols"
block in Unicode to Symbola. I got the Symbola font from the =ttf-ancient-fonts=
package on the AUR.
#+BEGIN_SRC emacs-lisp
(defvar og/unicode-font "DejaVu Sans")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x1d400 . #x1d7ff) og/unicode-font)
(set-fontset-font "fontset-default" '(#x2200 . #x22ff) og/unicode-font)
#+END_SRC
I do something similar for my =org-ellipsis= character (=⬎=); here, though, I just
prefer how this font draws the character.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x2b0e . #x2b0e) og/unicode-font)
#+END_SRC
I also include other miscellaneous characters.
#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" '(#x211c . #x211c) og/unicode-font) ;; real part ℜ
(set-fontset-font "fontset-default" '(#x2111 . #x2111) og/unicode-font) ;; imaginary part ℑ
(set-fontset-font "fontset-default" '(#x2113 . #x2113) og/unicode-font) ;; ell ℓ
(set-fontset-font "fontset-default" '(#x2118 . #x2118) og/unicode-font) ;; Weierstrass p ℘
(set-fontset-font "fontset-default" '(#x2135 . #x2135) og/unicode-font) ;; aleph ℵ
#+END_SRC
**** Syntax Highlighting
I want syntax highlighting everywhere...
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC
except in massive buffers, where it probably wouldn't be that useful (syntax
highlighting doesn't help you read a CSV file with thousands of lines) and would
definitely slow things down. In such buffers I also remove line numbers.
#+BEGIN_SRC emacs-lisp
(defun buffer-too-big-p ()
  (or (> (buffer-size) (* 5000 80))
      (> (line-number-at-pos (point-max)) 5000)))

(defun og/big-buffer-setup ()
  (when (buffer-too-big-p)
              (nlinum-relative-mode -1)
              (font-lock-mode -1)))

(add-hook 'prog-mode-hook #'og/big-buffer-setup)
#+END_SRC
Normally, I want the opening and closing parentheses highlighted. I used to set
=show-paren-style= to =expression=, but all that highlighting was not really
necessary. A great idea from [[https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/][(with-emacs]] is to advise the function that shows
matching parentheses to display an overlay with the appropriate matching line
when it is off-screen.
#+BEGIN_SRC emacs-lisp
(let ((ov nil)) ; keep track of the overlay
  (advice-add
   #'show-paren-function
   :after
   (defun show-paren--off-screen+ (&rest _args)
     "Display matching line for off-screen paren."
     (when (overlayp ov)
       (delete-overlay ov))
     ;; check if it's appropriate to show match info,
     ;; see `blink-paren-post-self-insert-function'
     (when (and (overlay-buffer show-paren--overlay)
                (not (or cursor-in-echo-area
                         executing-kbd-macro
                         noninteractive
                         (minibufferp)
                         this-command))
                (and (not (bobp))
                     (memq (char-syntax (char-before)) '(?\) ?\$)))
                (= 1 (logand 1 (- (point)
                                  (save-excursion
                                    (forward-char -1)
                                    (skip-syntax-backward "/\\")
                                    (point))))))
       ;; rebind `minibuffer-message' called by
       ;; `blink-matching-open' to handle the overlay display
       (cl-letf (((symbol-function #'minibuffer-message)
                  (lambda (msg &rest args)
                    (let ((msg (apply #'format-message msg args)))
                      (setq ov (display-line-overlay+
                                (window-start) msg ))))))
         (blink-matching-open))))))

(defun display-line-overlay+ (pos str &optional face)
  "Display line at POS as STR with FACE.

FACE defaults to inheriting from default and highlight."
  (let ((ol (save-excursion
              (goto-char pos)
              (make-overlay (line-beginning-position)
                            (line-end-position)))))
    (overlay-put ol 'display str)
    (overlay-put ol 'face 'bold)
    ol))

(remove-hook 'post-self-insert-hook #'blink-paren-post-self-insert-function)

(show-paren-mode 1)
(setq show-paren-style 'paren
      show-paren-delay 0.03
      show-paren-highlight-openparen t
      show-paren-when-point-inside-paren nil
      show-paren-when-point-in-periphery t)
#+END_SRC
Finally, =rainbow-mode= highlights hex-color strings with their colour. Very handy
for choosing colours, especially when editing CSS files.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :defer 3
  :diminish
  :config (rainbow-mode 1))
#+END_SRC
Highlight =.service= files like they are configuration files.
#+BEGIN_SRC emacs-lisp
(use-package systemd
  :commands systemd-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.service\\'" . systemd-mode))
  (add-to-list 'auto-mode-alist '("\\.timer\\'" . systemd-mode)))
#+END_SRC
** Quality of Life
*** Better Defaults
All the things (perhaps they seem little) that just make sense to have.
**** From Yes/No to y/n
This makes things so much simpler. There's not any ambiguity to begin with. And
it's two less characters to type.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** Stop Cursor Going into Minibuffer Prompt
Sometimes when going back in the minibuffer by using backspace or the left arrow
key, the cursor will move right back into the prompt, and when you start to type
again, Emacs will display the annoying message that the minibuffer text is read
only. This prevents you from manually having to move the cursor out of the
prompt and then back, or pressing =C-g= and starting over.
#+BEGIN_SRC emacs-lisp
(customize-set-variable
 'minibuffer-prompt-properties
 (quote (read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
**** Keystroke Echo Timeout
This is one of those things that I didn't think would be useful until I tried
it. When you type a keybinding, the key sequence shows up in the echo area. But
the default timeout, one second, is a bit too long for me.
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5)
#+END_SRC
**** Split Vertically by Default
Gotta maximize that vertical screen space. Besides, I always have 80 character
limits on my lines. To be honest, I have no idea how it works, but it seems to
make Emacs prefer splitting vertically.
#+BEGIN_SRC emacs-lisp
(setq split-height-threshold nil
      split-width-threshold 0)
#+END_SRC
**** Transient Mark Mode
#+BEGIN_SRC emacs-lisp
(transient-mark-mode 1)
#+END_SRC
**** Electric Pairs Mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC
**** Uniquify
Make two buffers with the same file name distinguishable. This isn't strictly
necessary because I use =smart-mode-line=, but the default style puts brackets
around the non-unique buffer names, and I prefer a less confusing style.
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC
**** Beginning of Line
[[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][This article]] argues that it's usually more useful for =C-a= to take you to the
beginning of the indentation of the line (that is, the logical/contextual
beginning of the line) as opposed to the literal beginning of the line. I tend
to agree. If you do want to go to the actual beginning of the line, then just
press =C-a= again. Also, this frees up =M-m=, bound to =back-to-indentation=.
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
(global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)
#+END_SRC
**** Faster Pop-to-mark
[[http://endlessparentheses.com/faster-pop-to-mark-command.html][Endless Parentheses]] shows us this modification to =pop-to-mark= (bound to =C-u
C-t=). Now we can pop the mark multiple times by pressing =C-t= again, rather than
having to type both keystrokes again.
#+BEGIN_SRC emacs-lisp
(defun modi/multi-pop-to-mark (orig-fun &rest args)
  "Call ORIG-FUN until the cursor moves.
Try the repeated popping up to 10 times."
  (let ((p (point)))
    (cl-loop repeat 10 do
             (when (= p (point))
               (apply orig-fun args)))))

(advice-add 'pop-to-mark-command :around #'modi/multi-pop-to-mark)
#+END_SRC
**** Integrate Clipboard and Kill Ring
If you copy something into your clipboard from, say, the browser, then you can
paste it into Emacs. That's all well and good. But if you kill something in
Emacs after copying something to the clipboard, what you had in the clipboard is
lost. That is, the clipboard cannot make use of the power that comes with the
multiple entries in the kill ring. Let's fix that by adding the system
clipboard's contents to the kill ring.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
**** Create Necessary Directories
I find it annoying to answer the prompt to make a new directory when making a
file in a nonexistent directory. And so we advise =find-file= to transparently
create necessary directories (from this [[https://superuser.com/questions/131538/can-i-create-directories-that-dont-exist-while-creating-a-new-file-in-emacs][SE post]]).
#+BEGIN_SRC emacs-lisp
(defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
  "Create parent directory if not exists while visiting file."
  (unless (file-exists-p filename)
    (let ((dir (file-name-directory filename)))
      (unless (file-exists-p dir)
        (make-directory dir)))))
#+END_SRC
**** Auto =chmod +x=
Make files that start with a =#!= shebang executable.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
*** Work with Protected Files
Authorize actions. The package =sudo-edit= is excellent for editing files owned by
root.
#+BEGIN_SRC emacs-lisp
(when og/user
  (use-package pinentry
    :config (pinentry-start))

  (use-package epa-file
    :ensure nil
    :config (setenv "GPG_AGENT_INFO" nil)
    :custom
    (epg-gpg-program "/usr/bin/gpg2")
    (epa-file-cache-passphrase-for-symmetric-encryption t)
    (epa-file-select-keys nil)
    (epa-pinentry-mode 'loopback))

  (use-package sudo-edit
    :commands sudo-edit))
#+END_SRC
*** Backups
Keep backups in a dedicated spot and not in the current directory: this saves a
lot clutter.
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name (concat gmacs-cache-dir "backups")))))
#+END_SRC
I have lots of disk space, and not so much patience when I lose an important
file. So I save lots.
#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1
      version-control t
      vc-make-backup-files t
      create-lockfiles nil)
#+END_SRC
**** Autosave
I want to move the autosaved stuff into the cache dir: let's keep everything
nice and neat.
#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,(expand-file-name (concat gmacs-cache-dir "auto-save")) t))
      auto-save-list-file-name (expand-file-name (concat gmacs-cache-dir "auto-save/.saves~")))
#+END_SRC
However, Emacs prints a lot of messages to the echo area telling you that a file
**** History
It's nice to have a history of commands and other things so that you can get
right to work when you open a new Emacs instance, you can get right to work.
Without this, =*table--cell-backward-kill-paragraph= is the default command,
because they are sorted alphabetically. If this has ever been the first command
you wanted to execute after opening Emacs, please let me know.
#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure nil
  :defer 2
  :config
  (defun recentf-save-list ()
    (let ((inhibit-message t))
      "Save the recent list.
Write data into the file specified by `recentf-save-file'."
      (interactive)
      (condition-case error
          (with-temp-buffer
            (erase-buffer)
            (set-buffer-file-coding-system recentf-save-file-coding-system)
            (insert (format-message recentf-save-file-header
                                    (current-time-string)))
            (recentf-dump-variable 'recentf-list recentf-max-saved-items)
            (recentf-dump-variable 'recentf-filter-changer-current)
            (insert "\n\n;; Local Variables:\n"
                    (format ";; coding: %s\n" recentf-save-file-coding-system)
                    ";; End:\n")
            (write-file (expand-file-name recentf-save-file))
            (when recentf-save-file-modes
              (set-file-modes recentf-save-file recentf-save-file-modes))
            nil)
        (error
         (warn "recentf mode: %s" (error-message-string error))))))
  (recentf-mode 1)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  :custom
  (recentf-save-file (expand-file-name "recentf" gmacs-cache-dir))
  (recentf-max-saved-items 1000)
  (recentf-max-menu-items 1000)
  (recentf-exclude '("/elpa/"
                     "/cache/"
                     "/tmp/)")))
#+END_SRC
Make things quieter.
#+BEGIN_SRC emacs-lisp
(defun suppress-messages (func &rest args)
  "Suppress message output from FUNC."
  ;; Some packages are too noisy.
  ;; https://superuser.com/questions/669701/emacs-disable-some-minibuffer-messages
  (cl-flet ((silence (&rest args1) (ignore)))
    (advice-add 'message :around #'silence)
    (unwind-protect
        (apply func args)
      (advice-remove 'message #'silence))))

;; Suppress "Cleaning up the recentf...done (0 removed)"
(advice-add 'recentf-cleanup :around #'suppress-messages)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq-default savehist-file (expand-file-name "savehist" gmacs-cache-dir)
              save-place-file (expand-file-name "saveplaces" gmacs-cache-dir)
              transient-history-file (expand-file-name "transient-history.el" gmacs-cache-dir)
              bookmark-default-file (expand-file-name "bookmarks" gmacs-cache-dir))
#+END_SRC
Now we specify what to save.
#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
*** Reloading
As I tinkered with my Emacs configuration, it quickly became clear to me that
reloading Emacs is useful when testing something out. There are three fronts on
which reloading is useful.

When a file is changed on the disk, I want the content in my Emacs buffer to
reflect that. The only problem with this is that you could lose data if you're
not careful but I autosave almost too often, so this is not a concern for me.
And so I enable =auto-revert-mode= globally. Given this, I silence the messages
that a buffer has been reverted.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-verbose nil)
(diminish 'auto-revert-mode)
#+END_SRC
When this doesn't work, I still want to be able to quickly revert a buffer
manually.
#+BEGIN_SRC emacs-lisp
(defalias 'rb 'revert-buffer)
(defalias 'arm 'auto-revert-mode)
#+END_SRC
The type of file I most often revert is PDFs, because I want to check the output
of =.tex= files exported from Org Mode. And so I don't need to double check before
I revert.
#+BEGIN_SRC emacs-lisp
(setq revert-without-query '("\\.pdf"))
#+END_SRC
Sometimes, however, there are other cases in which we want to reload a buffer.
The change have been not in the file's contents, but in an Emacs setting, such
as the colours of the theme. Or the buffer might not have been representing a
file at all. In these cases, it's usually easiest to revert every open buffer.
This might be a problem for you if you're one of those people who keeps hundreds
of buffers open at a time, but I like to close my buffers liberally with the
knowledge that =recentf= will remember where I've been for me. I obtained the
following function from [[https://emacs.stackexchange.com/questions/24459/revert-all-open-buffers-and-ignore-errors][Emacs Stack Exchange]].
#+BEGIN_SRC emacs-lisp
(defun modi/revert-buffers (&optional buffers)
  "Refresh all open file buffers without confirmation. If BUFFERS is given, revert all elements of BUFFERS instead.
Buffers in modified (not yet saved) state in emacs will not be reverted. They
will be reverted though if they were modified outside emacs.
Buffers visiting files which do not exist any more or are no longer readable
will be killed."
  (interactive)
  (unless buffers (setq buffers (buffer-list)))
  (dolist (buf buffers)
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer t t))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers."))
#+END_SRC
Other times, we need to reload Emacs fully. To completely reload Emacs, we just
run the procedure of =init.el= again. Usually, we want to load the byte-compiled
version, but for those cases where we just want to load the uncompiled =.el= file,
a prefix argument does the job. I disable =after-save-hook= because I set up
asynchronous tangling and byte-compilation [[#tangle-async][here]].

Finally, I hope it doesn't come to this too often, but sometimes we must close
Emacs entirely and start a new session. I know, I can feel the agony. =C-x C-c=,
then move your mouse to click Emacs again! Luckily, there's a package for that.
This kills Emacs and starts a new session.
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
Our function completely restarts, compiles and reloads with a prefix argument,
and just loads the existing =.el= file with two prefix arguments.
#+BEGIN_SRC emacs-lisp
(defun og/reload (p)
  (interactive "P")
  (let ((after-save-hook nil)
        (org (expand-file-name "gmacs.org" user-emacs-directory))
        (el (expand-file-name "gmacs.el" user-emacs-directory))
        (elc (expand-file-name "gmacs.elc" user-emacs-directory))
        (init (expand-file-name "init.el" user-emacs-directory)))
    (cond ((equal p '(4))
           (when (or (not (file-exists-p elc))
                     (file-newer-than-file-p org elc))
             (org-babel-tangle-file org el)
             (byte-compile-file el))
           (load-file init)
           (run-hooks 'after-init-hook))
          ((equal p '(16))
           (org-babel-load-file org))
          (t (restart-emacs)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'og/reload)
#+END_SRC
*** Abbreviations
Abbrevs are a pretty common and useful feature in editors. You can define
abbrevs, which are strings. When you type space after an abbrev, it is expanded
to whatever you want. Saves a lot of keystrokes.
#+BEGIN_SRC emacs-lisp
(setq abbrev-file-name (expand-file-name "abbrevs.el" user-emacs-directory))
(setq-default abbrev-mode t)
(setq save-abbrevs 'silently)
(diminish 'abbrev-mode)
(bind-key "C-c M a" #'abbrev-mode)
#+END_SRC
*** Async Without Results Window
#+BEGIN_SRC emacs-lisp
(defun async-shell-command-no-window (command)
  (interactive)
  (let ((display-buffer-alist
        (list (cons "\\*Async Shell Command\\*.*"
          (cons #'display-buffer-no-window nil)))))
    (async-shell-command
     command)))
#+END_SRC
*** Insert Key Sequence
This command takes a key sequence and inserts it into the buffer. This is
surprisingly much easier than typing it in manually. I got it from [[http://endlessparentheses.com/inserting-the-kbd-tag-in-org-mode.html][this article]].
#+BEGIN_SRC emacs-lisp
(defun endless/insert-key (key)
  "Ask for a key then insert its description.
Will work on both org-mode and any mode that accepts plain html."
  (interactive "kType key sequence: ")
  (let* ((orgp (derived-mode-p 'org-mode))
         (tag (if orgp "=%s=" "<kbd>%s</kbd>")))
    (if (null (equal key "\C-m"))
        (insert
         (format tag (help-key-description key nil)))
      (insert (format tag ""))
      (forward-char (if orgp -1 -6)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c k" . endless/insert-key)
#+END_SRC
*** Swap Windows
Every now and then, you'll want to switch the order of the buffers in Emacs.
This usually happens to me if I have something I'm reading in one buffer (code
reference, PDF) and something I'm writing in the other. I got this from
[[https://github.com/bbatsov/crux][bbatsov/crux]].
#+BEGIN_SRC emacs-lisp
(defun og/swap-windows (arg)
  "Transpose the buffers shown in two windows.
Prefix ARG determines if the current windows buffer is swapped
with the next or previous window, and the number of
transpositions to execute in sequence."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (> arg 0) (1- arg) (1+ arg))))))

(bind-key "C-x 4 t" #'og/swap-windows)
#+END_SRC
*** Tangle Config File
:PROPERTIES:
:CUSTOM_ID: tangle-async
:END:
I used to have my =init.el= set up so that, if =gmacs.elc= did not exist, it would
tangle =gmacs.org=. This unfortunately means that Emacs takes a long time to start
up (about 6 seconds). To solve this, I tangle this very file on save.

If the config file is already being tangled, we kill that process and start a
new one. I only really want to know about this process if it failed.
#+BEGIN_SRC emacs-lisp
(defvar og--tangle-process nil)

(defun og/tangle-gmacs ()
  (interactive)
  (let ((proc og--tangle-process)
        (kill-buffer-query-functions nil))
    (when (process-live-p proc)
      (kill-process proc)
      (kill-buffer (process-buffer proc))))
  (let ((proc (async-start
               (lambda ()
                 (require 'ob-tangle)
                 (org-babel-tangle-file (expand-file-name "gmacs.org" user-emacs-directory)))
               (lambda (result)
                 (unless result
                   (message "GMACS unsuccessfully tangled: %s" result))))))
    (setq og--tangle-process proc)))
#+END_SRC
*** Benchmarking
**** Functions
To optimize a function, you need to know the actual difference your changes
make.
#+BEGIN_SRC emacs-lisp
(autoload 'benchmark-elapse "benchmark")
#+END_SRC
**** Startup
If I introduce a new feature that increases my startup time, I can test things
out quantitatively with =esup=, a built-in feature.
#+BEGIN_SRC emacs-lisp
(use-package esup
  :commands esup)
#+END_SRC
*** UTF-8
From [[https://masteringemacs.org/article/working-coding-systems-unicode-emacs][Mastering Emacs]].
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(setq locale-coding-system 'utf-8)
(setq selection-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq session-save-file-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC
*** Faster Scroll Down
I found this snippet on [[https://emacs.stackexchange.com/questions/28736/emacs-pointcursor-movement-lag/28746][StackExchange]]. To summarize, =next-line= called
=line-move-partial=, which is expensive. The function =previous-line= does not do
this, so scrolling forward can sometimes feel jumpy, even when scrolling up is
smooth.
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC
*** Dump Vars to File
#+BEGIN_SRC emacs-lisp
(defun dump-vars-to-file (varlist filename &optional lines)
  "simplistic dumping of variables in VARLIST to a file FILENAME"
  (save-excursion
    (let ((buf (find-file-noselect filename)))
      (set-buffer buf)
      (erase-buffer)
      (dump varlist buf lines)
      (save-buffer))))

(defun dump (varlist buffer &optional lines)
  "insert into buffer the setq statement to recreate the variables in VARLIST"
  (let ((func (if lines 'pp 'print)))
  (cl-loop for var in varlist do
        (funcall func (list 'setq var (list 'quote (symbol-value var))) buffer))))
#+END_SRC
*** Add Package to Dotfiles
#+BEGIN_SRC emacs-lisp
(defun og/package-linux-add (&optional package)
  (interactive)
  (let ((file "~/dotfiles/packages.txt")
        (package (if package package (read-string "Package name: "))))
  (with-temp-file file
    (insert (concat package "\n"))
    (insert-file-contents file)
    (sort-lines nil (point-min) (point-max))
  (buffer-string))))
#+END_SRC
*** Get Matches in Buffer
#+BEGIN_SRC emacs-lisp
(defun matches-in-buffer (regexp &optional buffer)
  "return a list of matches of REGEXP in BUFFER or the current buffer if not given."
  (let ((matches))
    (save-match-data
      (save-excursion
        (with-current-buffer (or buffer (current-buffer))
          (save-restriction
            (widen)
            (goto-char 1)
            (while (search-forward-regexp regexp nil t 1)
              (push (match-string-no-properties 0) matches)))))
      matches)))
#+END_SRC
*** Alias
Make commands easier.
#+BEGIN_SRC emacs-lisp
(defalias 'md 'mkdir)
(defalias 'mk 'mkdir)
#+END_SRC
*** Update Environment Variables
We can reload the environment variables without restarting Emacs by sending this
command to the client.
#+BEGIN_SRC emacs-lisp
(defun og/update-env (fn)
  (let ((str
         (with-temp-buffer
           (insert-file-contents fn)
           (buffer-string)))
        lst)
    (setq lst (split-string str "\000"))
    (while lst
      (setq cur (car lst))
      (when (string-match "^\\(.*?\\)=\\(.*\\)" cur)
        (setq var (match-string 1 cur))
        (setq value (match-string 2 cur))
        (setenv var value))
      (setq lst (cdr lst)))))
#+END_SRC
*** Quit Current Context
Quit minibuffer more easily. No more hammering =C-g=.
#+BEGIN_SRC emacs-lisp
(defun keyboard-quit-context ()
  "Quit current context.

This function is a combination of `keyboard-quit' and
`keyboard-escape-quit' with some parts omitted and some custom
behavior added."
  (interactive)
  (cond ((region-active-p)
         ;; Avoid adding the region to the window selection.
         (setq saved-region-selection nil)
         (let (select-active-regions)
           (deactivate-mark)))
        ((eq last-command 'mode-exited) nil)
        (current-prefix-arg
         nil)
        (defining-kbd-macro
          (message
           (substitute-command-keys
            "Quit is ignored during macro defintion, use [kmacro-end-macro] if you want to stop macro definition"))
          (cancel-kbd-macro-events))
        ((active-minibuffer-window)
         (when (get-buffer-window "*Completions*")
           ;; hide completions first so point stays in active window when
           ;; outside the minibuffer
           (minibuffer-hide-completions))
         (abort-recursive-edit))
        (t
         (when completion-in-region-mode
           (completion-in-region-mode -1))
         (let ((debug-on-quit nil))
           (signal 'quit nil)))))

;; (global-set-key [remap keyboard-quit] #'keyboard-quit-context)
#+END_SRC
*** Don't Ask to Kill Processes on Quit
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-processes nil)
#+END_SRC
*** Undo Keyboard Macro in One Step
Undoes all parts of keyboard macro at once.
#+BEGIN_SRC emacs-lisp
(defun block-undo (fn &rest args)
  (let ((marker
         (prepare-change-group)))
    (unwind-protect (apply fn args)
      (undo-amalgamate-change-group marker))))

(dolist (fn '(kmacro-call-macro kmacro-exec-ring-item))
  (advice-add fn :around #'block-undo))
#+END_SRC
** Wordsmithing
*** Basic Configuration
**** Sentences End With a Single Space
This is necessary to make sentence navigation commands work for me. I also don't
live in the typewriter days where there are two spaces after a period.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
**** Delete Selection
#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
**** Don't Adjust Point When Pasting by Mouse
Pasting into Emacs by middle-clicking can be nice, but I don't want the click to
change the location of the point and then paste there instead of where the point
originally was.
#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC
**** Ban Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook #'delete-trailing-whitespace)
#+END_SRC
**** Autofill
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
(diminish 'visual-line-mode)
#+END_SRC
Nicely wrap lines for text mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
(add-hook 'change-log-mode-hook 'turn-on-auto-fill)
(diminish 'auto-fill-function)
#+END_SRC
Default wrap at 80 characters.
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC
*** Utilities
**** Dictionary
See this [[http://jsomers.net/blog/dictionary][beautiful post]] by James Somers on why you should use this dictionary.
It's Webster's original, his magnum opus.
#+BEGIN_SRC emacs-lisp
(autoload #'sdcv-search "sdcv-mode")
(bind-key "C-c d" #'sdcv-search)
#+END_SRC
On Arch Linux, this goes with the =sdcv= package.
**** Writing
A minor mode that centres the text in the buffer. Nice distraction-free
environment for writing.
#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :commands olivetti-mode)
#+END_SRC
A major mode for writing screenplays in the =.fountain= format.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package fountain-mode
  :commands fountain-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.fountain\\'" . fountain-mode))
  :config
  (add-hook 'fountain-mode-hook
            (lambda () (auto-fill-mode -1)
              (olivetti-mode 1)))
  <<fountain-mode>>
  :custom
  (fountain-export-font "Courier New")
  (fountain-export-scene-heading-format '(bold)))
#+END_SRC
The default export function has some annoying behaviour such as asking if you
want to overwrite the exported file and switching to the export buffer, so I
redefine the function here.
#+BEGIN_SRC emacs-lisp :noweb-ref fountain-mode
(defun fountain-export-buffer (format &optional snippet buffer)
  "Export current buffer or BUFFER to export format FORMAT.

If destination buffer is not empty, ask to overwrite or generate
a new buffer. If destination buffer is the same as source buffer,
generate a new buffer.

Switch to destination buffer if complete without errors,
otherwise kill destination buffer."
  ;; If called interactively, present export format options.
  (interactive
   (list (intern
          (completing-read "Export format: "
                           (mapcar #'car fountain-export-formats) nil t))
         (car current-prefix-arg)))
  (unless buffer
    (save-buffer)
    (setq buffer (current-buffer)))
  (let ((dest-buffer (get-buffer-create
                      (fountain-export-get-filename format buffer)))
        (hook (plist-get (cdr (assq format fountain-export-formats))
                         :hook))
        string complete)
    (unwind-protect
      ;; Export the region to STRING.
      (setq string
            (fountain-export-region (point-min) (point-max) format snippet))
      ;; Insert STRING into DEST-BUFFER.
      (with-current-buffer dest-buffer
        (with-silent-modifications
          (erase-buffer)
          (insert string))
        (write-file (buffer-name)))
      (run-hooks hook))))
#+END_SRC
**** Easier Regexp
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :commands (anzu-query-replace anzu-query-replace-regexp)
  :diminish "杏"
  :bind
  (([remap query-replace] . 'anzu-query-replace)
   ([remap query-replace-regexp] . 'anzu-query-replace-regexp))
  :config
  (unless (keymap-parent lisp-mode-shared-map)
    (set-keymap-parent lisp-mode-shared-map prog-mode-map))
  (bind-key [convert] #'anzu-query-replace-at-cursor-thing prog-mode-map))
#+END_SRC
*** Spelling
**** Setup
The article [[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]] helped me out in setting up spellchecking in
my own Emacs configuration.

We automatically spellcheck text buffers using =flyspell=. The only mode I write
prose in is Org Mode.
#+BEGIN_SRC emacs-lisp :noweb no-export
(defvar og/spelling nil)

(use-package flyspell
  :diminish
  :commands flyspell-mode
  :init
  (add-hook 'org-mode-hook #'flyspell-mode)
  (after! notmuch
    (add-hook 'notmuch-message-mode-hook #'flyspell-mode))
  <<flyspell-init>>
  :config
  <<flyspell-settings>>)
#+END_SRC
Set up spellchecking using =ispell= and the dictionary =hunspell=. We set the
locally used dictionary to Canadian English, and we set up the list of valid
dictionaries. I found the official Canadian English dictionary [[https://sourceforge.net/projects/wordlist/files/speller/2018.04.16/hunspell-en_CA-2018.04.16.zip/download?use_mirror=ayera][here]] (warning:
download link). The =.aff= and =.dic= files go in =/usr/share/hunspell/=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq ispell-program-name "hunspell"
      ispell-local-dictionary "en_CA"
      ispell-hunspell-dictionary-alist
      '(("en_CA" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_CA") nil utf-8)))
#+END_SRC
As suggested by the Emacs wiki, I suppress messages, which slows down
performance when checking the entire buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(setq-default flyspell-issue-message-flag nil
              flyspell-issue-welcome-flag nil)
#+END_SRC
Spellchecking should not occur inside certain parts of Org Mode buffers like
property drawers and code source blocks. From [[http://endlessparentheses.com/ispell-and-org-mode.html?source=rss][Making Ispell work with org-mode in Emacs]].
#+BEGIN_SRC emacs-lisp
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("^#\+.*$"))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))

(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
**** Autocorrect and Abbreviations and Avy Selection
We want to be able to go to the previous error and correct it, then add it to
our global abbreviation list. As long as we spell the word incorrectly the same
way, we'll never make that typo again. I used to use code I took and modified
from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Artur Malabarba]] and Howard Abrams, but now I just set this variable built
into =flyspell=.
#+BEGIN_SRC emacs-lisp :tanle no :noweb-ref flyspell-init
(setq flyspell-abbrev-p t)
#+END_SRC
However, I'm not a fan of the default interface for selecting spelling
corrections. Many forces in Emacs fight for window space, from expanded
minibuffers to popup windows. Both have their disadvantages. The minibuffer is
away from the action and requires you to look to a different place on the
screen. Popup windows can easily cause a jarring change in the way content is
displayed on the buffer. The solution is a [[https://github.com/alphapapa/frog-menu][frog menu]].

Its role is not fixed, but ad hoc; it pops up at the right moment in the right
place, just as the frog's tongue pouncing on the fly.

We use the =flyspell-correct= package to implement such an interface. It uses =avy=
for selection.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(autoload 'frog-menu-read "frog-menu")
(use-package flyspell-correct
  :commands flyspell-correct-wrapper
  :custom
  (flyspell-correct-interface #'frog-menu-flyspell-correct))
#+END_SRC
This code is from the =frog-menu= GitHub.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-init
(defun frog-menu-flyspell-correct (candidates word)
  "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
  (let* ((corrects (if flyspell-sort-corrections
                       (sort candidates 'string<)
                     candidates))
         (actions `(("C-s" "Save word"         (save    . ,word))
                    ("C-a" "Accept (session)"  (session . ,word))
                    ("C-b" "Accept (buffer)"   (buffer  . ,word))
                    ("C-c" "Skip"              (skip    . ,word))))
         (prompt   (format "Correcting %s with [%s]"
                           word
                           (or ispell-local-dictionary
                               ispell-dictionary
                               "default")))
         (res      (frog-menu-read prompt corrects actions)))
    (unless res
      (error "Quit"))
    res))
#+END_SRC
[[http://pragmaticemacs.com/emacs/jump-back-to-previous-typo/][This article]] thinks that going to the previous error is more useful than going
to the next one. This is usually true, and aligns with the default behaviour
=flyspell-correct-wrapper=. The default binding on =C-;= is =flyspell='s built-in
autocorrect function. However, its suggestions are often not so useful, and
we've subsumed its role with =flyspell-correct= anyway.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flyspell-settings
(bind-key [remap flyspell-auto-correct-previous-word]
          #'flyspell-correct-wrapper flyspell-mode-map)
#+END_SRC
When moving backwards in the document, the correction menu can appear at the top
of the screen, obscuring the context surrounding the error.
#+BEGIN_SRC emacs-lisp
;; (advice-add 'flyspell-correct-wrapper :before #'recenter-top-bottom)
#+END_SRC
**** Correct Double Capitals
Taken from [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type/13975#13975][Stack Exchange]]. It's a piece of code with a great impact to
complexity ratio. Whenever you're a bit slow in releasing the Shift key and type
something like "This," =dubcaps-mode= converts it to "This" for you automatically.
This isn't really a hindrance, because if I actually want two capital letters in
a row, I almost never want a lowercase letter to follow.
#+BEGIN_SRC emacs-lisp
(defun og/dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (let ((point (point)))
    (when (and (= ?w (char-syntax (char-before)))
               (save-excursion
                 (and (if (called-interactively-p 'interactive)
                          (skip-syntax-backward "w")
                        (= -3 (skip-syntax-backward "w")))
                      (let (case-fold-search)
                        (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                      (og/capitalize-word))))
      (goto-char point))))

(define-minor-mode og/dubcaps-mode
  "Toggle `og/dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  (if og/dubcaps-mode
      (add-hook 'post-self-insert-hook #'og/dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'og/dcaps-to-scaps 'local)))
#+END_SRC
**** Remove Words
Sometimes we accidentally add a word to our personal list and want to remove it.
#+BEGIN_SRC emacs-lisp
(defun og/remove-personal-word ()
  (interactive)
  (let ((file (format "~/.hunspell_%s" ispell-local-dictionary))
        wordlist)
    (progn
      (find-file "~/.hunspell_en_CA")
      (setq wordlist (buffer-string))
      (kill-buffer))
    (let* ((words (nreverse (split-string wordlist "\n")))
           (word (ivy-read "Word to delete: " words))))
    (with-temp-file file
      (setq words (delete word words))
      (dolist (w words)
        (insert (format "%s\n" w))))))
#+END_SRC
*** Text Manipulation
If there is no region active, operate on the current line.
#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :defer 1
  :bind (:map global-map
              ("C-k" . 'whole-line-or-region-kill-region)
              ("M-w" . 'whole-line-or-region-copy-region-as-kill))
        (:map org-mode-map
              ("C-k" . 'whole-line-or-region-kill-region)
              ("M-w" . 'whole-line-or-region-copy-region-as-kill)))
#+END_SRC
**** Paragraph Navigation
Keep blank lines as paragraph delimiters, no matter the major mode. From [[http://endlessparentheses.com/meta-binds-part-2-a-peeve-with-paragraphs.html][Meta
Binds Part 2: A peeve with paragraphs]].
#+BEGIN_SRC emacs-lisp
(bind-key "M-p" 'endless/backward-paragraph)
(bind-key "M-n" 'endless/forward-paragraph)

(defun endless/forward-paragraph (&optional n)
  "Advance just past next blank line."
  (interactive "p")
  (let ((para-commands
         '(endless/forward-paragraph endless/backward-paragraph)))
    ;; Only push mark if it's not active and we're not repeating.
    (or (use-region-p)
        (not (member this-command para-commands))
        (member last-command para-commands)
        (push-mark))
    ;; The actual movement.
    (dotimes (_ (abs n))
      (if (> n 0)
          (skip-chars-forward "\n[:blank:]")
        (skip-chars-backward "\n[:blank:]"))
      (if (search-forward-regexp
           "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
          (goto-char (match-end 0))
        (goto-char (if (> n 0) (point-max) (point-min)))))))

(defun endless/backward-paragraph (&optional n)
  "Go back up to previous blank line."
  (interactive "p")
  (endless/forward-paragraph (- n)))
#+END_SRC
But Org Mode messes this up. So we setup a binding using the =:bind= keyword from
=use-package=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("M-n" . forward-paragraph)
("M-p" . backward-paragraph)
#+END_SRC
**** Transpose Elements
Add aliases to do this easily.
#+BEGIN_SRC emacs-lisp
(defalias 'ts 'transpose-sentences)
(defalias 'tp 'transpose-paragraphs)
(bind-key "C-r" 'transpose-chars)
#+END_SRC
**** Capitalize Word
The default behaviour, that pressing =M-c= here (with the cursor at =|=) =capit|alize=
produces =capitAlize= is silly; I can't think of a situation where I would want to
capitalize just the following character if the cursor is in the middle of a
word.
#+BEGIN_SRC emacs-lisp
(defun og/capitalize-word ()
  (interactive)
  (let ((eol (eolp)))
    (when (and (eq (char-before) ? )
               (or (eq (char-after) ? )
                   (eolp)))
      (backward-char))
    (let* ((bounds (bounds-of-thing-at-point 'symbol))
           (beg (car bounds))
           (end (cdr bounds))
           (word (buffer-substring-no-properties beg end)))
      (delete-region beg end)
      (if (string= word (capitalize word))
          (insert (downcase word))
        (insert (capitalize word))))
    (if eol
        (forward-char)
      (forward-word)
      (backward-word))))

(bind-key "M-c" #'og/capitalize-word)
#+END_SRC
**** Expand Region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands er/expand-region
  :bind (("C-=" . er/expand-region)
         ("M-2" . er/expand-region)))
#+END_SRC
**** Replace String
#+BEGIN_SRC emacs-lisp
(defalias 'rs 'replace-string)
#+END_SRC
** Programming
The age old debate: tabs or spaces? I say spaces.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 2)
#+END_SRC
Make =TAB= indent first then perform completion, if any.
#+BEGIN_SRC emacs-lisp
(setq-default tab-always-indent 'complete)
#+END_SRC
Set up =flycheck=.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package flycheck
  :commands flycheck-mode
  :diminish (flycheck-mode " Ψ")
  :custom (flycheck-display-errors-delay .3)
  :hook (prog-mode . flycheck-mode))
#+END_SRC
Relative line numbers, useful for Vim-like navigation with God Mode.
#+BEGIN_SRC emacs-lisp
(use-package nlinum-relative
  :hook (prog-mode . nlinum-relative-mode))
#+END_SRC
Emacs treats camelCase strings as a single word by default. Not anymore.
#+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
#+END_SRC
We use =lsp-mode= to set up an IDE.
#+BEGIN_SRC emacs-lisp
(use-package company
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0))

(use-package lsp-mode
  ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  :init (setq lsp-keymap-prefix "s-l")
  :commands lsp
  :config
  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
  (use-package company-lsp :commands company-lsp))
#+END_SRC
*** Flycheck Hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-flycheck (:color blue)
  "
  ^
  ^Flycheck^          ^Errors^            ^Checker^
  ^────────^──────────^──────^────────────^───────^─────
  _q_ quit            _<_ previous        _?_ describe
  _M_ manual          _>_ next            _d_ disable
  _v_ verify setup    _f_ check           _m_ mode
  ^^                  _l_ list            _s_ select
  ^^                  ^^                  ^^
  "
  ("q" nil)
  ("<" flycheck-previous-error :color pink)
  (">" flycheck-next-error :color pink)
  ("?" flycheck-describe-checker)
  ("M" flycheck-manual)
  ("d" flycheck-disable-checker)
  ("f" flycheck-buffer)
  ("l" flycheck-list-errors)
  ("m" flycheck-mode)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup))

(bind-key "C-c f" #'hydra-flycheck/body)
#+END_SRC
suppress
*** Python
Indent with 4 spaces.
#+BEGIN_SRC emacs-lisp
(setq-default python-indent-offset 4)
#+END_SRC
Turn Emacs into basically a Python IDE.
# #+BEGIN_SRC emacs-lisp
# (use-package elpy
#   :config
#   (use-package py-autopep8
#     :hook (elpy-mode . py-autopep8-enable-on-save))
#   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
#   :hook
#   (python-mode . elpy-enable)
#   (python-mode . elpy-mode)
#   (elpy-mode . flycheck-mode))
# #+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package sage-shell-mode)
(use-package ob-sagemath)
#+END_SRC
*** Lisp
Because =use-package= is never actually evaluated/loaded if we byte-compile
=gmacs.el=, it is not automatically syntax-highlighted as a macro.
#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'emacs-lisp-mode
  '(("use-package " . font-lock-keyword-face)))
#+END_SRC
We don't want annoying comments about having, for example, =;;; package ---
summary= at the top of an Emacs Lisp file.
#+BEGIN_SRC emacs-lisp
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
#+END_SRC
Sexps are everything in Lisp. The default bindings to traverse them forwards and
backwards are clunky: =C-M-f=, =C-M-b=. Since I've already taken my =M-digit=
[[*Window Management][bindings]], I'm willing to do it again.
#+BEGIN_SRC emacs-lisp
(bind-key "M-9" #'backward-sexp)
(bind-key "M-0" #'forward-sexp)
#+END_SRC
*** C++
#+BEGIN_SRC emacs-lisp
(setq-default c-default-style "linux"
              c-basic-offset 2)
#+END_SRC
** Packages
*** Package Management
**** Initialize During Emacs
Fix loading the GNU archive.
#+BEGIN_SRC emacs-lisp
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+END_SRC
Although we load and initialize all packages at startup, it is sometimes useful
for the user to be able to interact with this process after it has taken place.
For example, packages must be initialized to evaluate code blocks with
=use-package= declarations in them.
#+BEGIN_SRC emacs-lisp :noweb no-export
(defun og/package-intiialize ()
  (interactive)
  <<pack-arch>>
  (require 'use-package)
  (package-initialize)
  (package-refresh-contents))
#+END_SRC
**** Helpful
This package is a more informative alternative to the default Emacs
documentation/help feature. The [[https://github.com/Wilfred/helpful][author's pictures]] explain it better than I
could.
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)
   ("C-h F" . helpful-function)       ; no macros
   ("C-h C" . helpful-command)        ; only interactive functions
  )
  :commands (helpful-callable
             helpful-variable
             helpful-key
             helpful-function
             helpful-command))
#+END_SRC
*** Special Modes
**** PDF Viewing
#+BEGIN_SRC emacs-lisp
(defun og-pdf-open-external (&optional filename)
  (interactive)
  (require 'dired-open)
  (let (close)
    (unless filename
      (setq filename (file-truename buffer-file-name))
      (setq close t))
    (dired-open--start-process filename "xdg-open")
    (when close
      (kill-buffer-and-window))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package doc-view
  :bind (:map doc-view-mode-map ("O" . #'og-pdf-open-external)))
#+END_SRC
Open with external viewer by default if wanted.
#+BEGIN_SRC emacs-lisp
(use-package openwith
  :custom (openwith-associations '(("\\.pdf\\'" "zathura" (file))
                                   ("\\.djvu\\'" "zathura" (file))
                                   ("\\.\\(?:jp?g\\|png\\)\\'" "pqiv" (file)))))
#+END_SRC
**** Epub Reading
We use =nov.el=. Change default reading font from Source Sans Pro (my default
variable pitch font) to Minion Pro.
#+BEGIN_SRC emacs-lisp
(defun og/nov-font-setup ()
  (face-remap-add-relative 'variable-pitch :family "Minion Pro"
                                           :height 2.0))
#+END_SRC
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package nov
  :commands (nov-mode)
  :init (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  :hook (nov-mode . og/nov-font-setup)
  :config
  <<nov-settings>>)
#+END_SRC
Justifying e-book text. This code was taken from [[https://github.com/wasamasa/nov.el][wasamasa/nov.el]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref nov-settings
(require 'justify-kp)
(setq nov-text-width most-positive-fixnum)

(defun my-nov-window-configuration-change-hook ()
  (my-nov-post-html-render-hook)
  (remove-hook 'window-configuration-change-hook
               'my-nov-window-configuration-change-hook
               t))

(defun my-nov-post-html-render-hook ()
  (if (get-buffer-window)
      (let ((max-width (pj-line-width))
            buffer-read-only)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when (not (looking-at "^[[:space:]]*$"))
              (goto-char (line-end-position))
              (when (> (shr-pixel-column) max-width)
                (goto-char (line-beginning-position))
                (pj-justify)))
            (forward-line 1))))
    (add-hook 'window-configuration-change-hook
              'my-nov-window-configuration-change-hook
              nil t)))

(add-hook 'nov-post-html-render-hook 'my-nov-post-html-render-hook)
#+END_SRC
**** TeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex)
#+END_SRC
**** Webmode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode ("\\.scss\\'" . web-mode)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2))
#+END_SRC
*** Eshell
I have started to use =eshell= as my primary shell. This command ensures that
=eshell= is opened next to, not instead of, my current buffer.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package eshell
  :ensure nil
  :commands eshell
  :init
  <<eshell-init>>
  :config
  <<eshell>>)
#+END_SRC
Use =counsel= to load history.
#+BEGIN_SRC emacs-lisp
(after! counsel
  (bind-key [remap eshell-previous-matching-input] #'counsel-esh-history))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell-init
(defun eshell-other-frame (arg)
  "Open `eshell' in a new frame."
  (interactive "P")
  (let ((buf
         (let ((current-prefix-arg arg))
           (call-interactively 'eshell))))
    (switch-to-buffer (other-buffer buf))
    (switch-to-buffer-other-frame buf)))
#+END_SRC
I rebind the redundant help binding (there is already a more convenient prefix
map at =C-h=).
#+BEGIN_SRC emacs-lisp
(bind-key "<f1>" #'eshell-other-frame)
#+END_SRC
We also make some aliases.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(defun eshell/ff (&rest args)
  (apply #'find-file args))

(defun eshell/d (&rest args)
  (apply #'dired args))
#+END_SRC
My current workflow is to spawn =eshell= in a new frame, so I "advise" =exit= to
also kill the frame. However, I also don't want errors when there is only one
frame.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(defun eshell/exit ()
  (condition-case nil
      (let ((buf (current-buffer)))
        (with-current-buffer (get-buffer-create "*eshell messages*")
          (if (= 1 (length (frame-list)))
              (bury-buffer)
            (kill-buffer buf)
            (delete-frame))))
    (error nil)))
#+END_SRC
For command-line aliases, we don't need to read and write the file each time,
because we're not defining anything new, so we can write manually.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eshell
(after! em-alias
  (dolist
      (alias
       '(("x" "exit")
         ("l" "ls -1A $*")
         ("la" "ls -lAh $*")
         ("ll" "ls -lh $*")
         ("cpv" "cp -iv $*")
         ("mvv" "mv -iv $*")
         ("rmv" "rm -v $*")
         ("md" "eshell/mkdir -p $*")
         ("mdc" "eshell/mkdir -p $* ; cd $1")))
    (add-to-list 'eshell-command-aliases-list alias))
(eshell-write-aliases-list))
#+END_SRC
Use TRAMP to use Eshell as root.
#+BEGIN_SRC emacs-lisp
(require 'em-tramp)
(setq password-cache t)
(setq password-cache-expiry 3600)
#+END_SRC
Don't load the banner, and load TRAMP.
#+BEGIN_SRC emacs-lisp
(after! esh-module
  (delq 'eshell-banner eshell-modules-list)
  (push 'eshell-tramp eshell-modules-list))
#+END_SRC
Increase default history size.
#+BEGIN_SRC emacs-lisp
(setq eshell-history-size nil)
#+END_SRC
*** Dired
Great for renaming files in bulk.
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package dired
  :ensure nil
  :commands dired
  :config
  <<dired-settings>>)
#+END_SRC
Easily sort based on a lot of options such as name, time, size, and
extension. Use ~S~ to use in a Dired buffer.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-quick-sort
  :config (dired-quick-sort-setup))
#+END_SRC
I don't have much of a use for just listing the contents of a directory, and I
sometimes accidentally use this command instead of =dired=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "C-x C-d" #'dired)
#+END_SRC
Have the most up-to-date version of the buffer when using Dired.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
Don't show details by default.
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+END_SRC
Allow the user to copy the full file path.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(defun og/dired-copy-path-at-point ()
    (interactive)
    (dired-copy-filename-as-kill 0))

(bind-key "W" #'og/dired-copy-path-at-point dired-mode-map)
#+END_SRC
Show recursive folder sizes.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-du
  :commands dired-du-mode
  :hook (dired-du-mode . (lambda! () (dired-du--toggle-human-readable)
                                  (dired-du--toggle-human-readable)))
  :bind (:map dired-mode-map
              ("C-x M-r" . dired-du-mode)))
#+END_SRC
For more involved needs, there is also a dedicated package for analyzing disk
usage.
#+BEGIN_SRC emacs-lisp
(use-package disk-usage
  :commands (disk-usage))
#+END_SRC
Allow Dired to recursively copy and delete directories. The option ~always~
ensures that no confirmation dialog comes up; ~top~ would do it only one layer
deep.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
#+END_SRC
But I don't want to permanently delete things. Not yet, anyway.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq delete-by-moving-to-trash t)
#+END_SRC
Even then, I sometimes want to actually delete files.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(after! dired
  (defun og/really-delete ()
    (interactive)
    (let ((delete-by-moving-to-trash nil))
      (dired-do-delete))
    (revert-buffer)))
(bind-key "F" #'og/really-delete dired-mode-map)
(add-hook 'dired-mode-hook (lambda () (bind-key "F" #'og/really-delete dired-mode-map)))
#+END_SRC
We might as well perform file operations asynchronously.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(autoload 'dired-async-mode "dired-async" nil t)
(add-hook 'dired-mode-hook 'dired-async-mode)
#+END_SRC
When you open, say, an audio or video file from Dired, Emacs displays the raw
data in that file in a text buffer. We want to open files with the appropriate
application.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(autoload 'dired-open-xdg "dired-open")
(bind-key "O" #'dired-open-xdg dired-mode-map)
#+END_SRC
Condense unique subtrees like GitHub does.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(use-package dired-collapse
  :ensure nil
  :hook (dired-mode . dired-collapse-mode))
#+END_SRC
Always follow symlinks to their source if the source is version
controlled.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(setq vc-follow-symlinks t)
#+END_SRC
For really big files, =rsync= is nice.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(defun og/dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to: "
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "C" #'og/dired-rsync dired-mode-map)
#+END_SRC
I often find the commands in Dired hard to remember.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_z_ compress file  ^ ^              ^ ^                ^ ^                _?_ summary
_Z_ compress       _A_ find regexp  _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" og/dired-rsync)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-settings
(bind-key "." 'hydra-dired/body dired-mode-map)
#+END_SRC
*** Magit
Magit, the magical Git client, is an amazing porcelain for Git inside of Emacs.
Seriously, I've forgotten how tedious using Git on the command line is, and
every time I have to is a pain. Emacs is worth using for this package alone. We
only load it from the entry points given in =:commands=. We also define a
quick-bind to quit the current Magit session and return to the previous window
configuration. This way, we can let Magit take up the full real estate on the
screen, and once we're done, we can get right back to where we left off.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all)
  :init
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source)
  (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
  (remove-hook 'magit-status-sections-hook 'magit-insert-status-headers)
  :bind (("C-x g" . magit-status)
         :map magit-status-mode-map
         ("q" . magit-quit-session)))

(use-package ssh-agency
  :after magit)
#+END_SRC
*** Tramp
Don't keep backups: this is slow.
#+BEGIN_SRC emacs-lisp
(setq tramp-auto-save-directory nil)
#+END_SRC
Set tramp connection history location.
#+BEGIN_SRC emacs-lisp
(after! tramp-cache
  (setq tramp-persistency-file (expand-file-name "tramp" gmacs-cache-dir)))
#+END_SRC
*** Ivy
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package ivy
  :diminish
  :demand t
  :config
  (ivy-mode 1)
  <<ivy>>
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-display-style 'fancy)
  (ivy-initial-inputs-alist nil))

(use-package flx
  :after ivy)

(use-package swiper
  :after ivy
  :commands (swiper swiper-all))

(use-package counsel
  :after ivy
  :bind
  ([remap execute-extended-command] . counsel-M-x)
  ([remap org-goto] . counsel-org-goto)
  ([remap find-file] . counsel-find-file)
  ("C-s" . counsel-grep-or-swiper)
  (:map ivy-minibuffer-map
        ([remap hungry-delete-backward] . nil))
  :custom
  (counsel-grep-base-command
   "rg -i -M 120 --color auto --line-number %s %s"))

(use-package amx
  :commands (amx)
  :custom
  (amx-save-file (expand-file-name "amx" gmacs-cache-dir))
  (amx-history-length 50)
  (amx-show-key-bindings nil))
#+END_SRC
Use fuzzy search in most places.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
(setq ivy-re-builders-alist
   '((t . ivy--regex-fuzzy)
     (swiper . ivy--regex-plus)
     (ivy-switch-buffer . ivy--regex-plus)))
#+END_SRC
I want to ignore certain file extensions when searching for a file, so I add
them to the regexp in =counsel-find-file-ignore-regexp=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
(defconst og/find-file-ignore-extensions
  '("aux" "bbl" "blg" "exe" "log" "meta" "out" "fls" "tdo" "toc" "xdv" "fdx" "bcf" "run.xml"
    "bbl-SAVE-ERROR" "bcf-SAVE-ERROR"
    "synctex.gz" "fdb_latexmk"
    "elc"
    "pyc"))

(defconst og/find-file-ignore-dirs
  '("cache/" "auto/" "ltximg/"
    ".git/"
    "VideoDecodeStats/"))

(setq counsel-find-file-ignore-regexp
      (string-join (list (concat
                          (regexp-opt
                           (cl-loop for ext in og/find-file-ignore-extensions
                                    collect (concat "." ext)))
                          "\\'")
                         (regexp-opt og/find-file-ignore-dirs))
                   "\\|"))
#+END_SRC
We do something similar for =ivy-switch-buffer=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
(defconst og/find-file-ignore-names
  '("*elfeed-org*"
    ".org-gcal-token"))

(add-to-list 'ivy-ignore-buffers (regexp-opt og/find-file-ignore-names))
#+END_SRC
[[http://pragmaticemacs.com/page/6/][This post]] explains the pitfalls of the default behaviour of =ivy-yank-word= and
how to fix them. Now we can easily search for the word at point using =swiper=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ivy
;; version of ivy-yank-word to yank from start of word
(defun bjm/ivy-yank-whole-word ()
  "Pull next word from buffer into search string."
  (interactive)
  (let (amend)
    (with-ivy-window
      ;;move to last word boundary
      (re-search-backward "\\b")
      (let ((pt (point))
            (le (line-end-position)))
        (forward-word 1)
        (if (> (point) le)
            (goto-char pt)
          (setq amend (buffer-substring-no-properties pt (point))))))
    (when amend
      (insert (replace-regexp-in-string "  +" " " amend)))))

(bind-key "M-w" #'bjm/ivy-yank-whole-word ivy-minibuffer-map)
#+END_SRC
*** God Mode
In =god-mode=, all keypresses are interpreted as if preceded by =C-= (as in
"Control"). For example, the sequence =2 n x s= goes down two lines then saves the
buffer.
#+BEGIN_SRC emacs-lisp
(use-package god-mode
  :commands (god-local-mode god-mode-all))
#+END_SRC
Easily enter God Mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref keychord
(key-chord-define-global "jk" 'god-mode-all)
#+END_SRC
Indicate whether we're in God mode with the cursor colour. I've seen other
people do this by having a bar cursor in "insert mode" (to borrow some
terminology from Vim) and a block cursor in "command mode" (in our case, God
Mode).
#+BEGIN_SRC emacs-lisp
(defun og/god-mode-indicator ()
  (cond (god-local-mode
         (set-cursor-color "#dc322f"))
        (t (set-cursor-color "#657b83"))))

(add-hook 'god-mode-enabled-hook #'og/god-mode-indicator)
(add-hook 'god-mode-disabled-hook #'og/god-mode-indicator)
#+END_SRC
*** Hydra
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package hydra
  :config
  <<hydra>>)
#+END_SRC
*** Which Key Mode
Helpful when you want to see completion for a certain sequence of prefix keys.
#+BEGIN_SRC emacs-lisp
(which-key-mode)
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (("M-g" . avy-goto-word-1)))
#+END_SRC
Similarly, we use =ace-link= to open links quickly.
#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :commands (ace-link-addr)
  :config (ace-link-setup-default)
  (after! org
    (bind-key "M-O" #'ace-link-org org-mode-map)))
#+END_SRC
We set up some easier to read faces.
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(avy-lead-face ((t (:inherit isearch-fail))))
 '(avy-lead-face-0 ((t (:inherit org-todo :background "#002b36")))))
#+END_SRC
*** Window Management
I don't like the default Emacs functionality of splitting windows but not
switching to the new window. I find myself pressing =M-3 C-x 0= pretty much every
time I split the window.
#+BEGIN_SRC emacs-lisp
(defun og/split-window-below-and-switch ()
  (interactive)
  (split-window-below)
  (other-window 1))

(defun og/split-window-right-and-switch ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC
To manage my windows. I use =ace-window=. The nice thing about this is that when
you use the equivalent of =other-window=, you don't have to remember which window
the "other one" is. Instead, you select the window with a number.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window
             delete-window
             delete-other-windows
             og/split-window-right-and-switch
             og/split-window-below-and-switch)
  :bind (("C-x o" . ace-window)
         ("M-o" . ace-window)
         ("C-x 0" . delete-window)
         ("M-1" . delete-other-windows)
         ("M-3" . og/split-window-right-and-switch)
         ("M-4" . og/split-window-below-and-switch)))
#+END_SRC
*** Projectile
A neat package to perform operations with respect to the active "project,"
usually a git repo. The most useful function for me is =projectile-find-file=.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :config
  (use-package counsel-projectile :demand t)
  (projectile-mode)
  (projectile-load-known-projects))
#+END_SRC
I use a hydra to manage its many keybindings.
#+BEGIN_SRC emacs-lisp :noweb-ref hydra
(defhydra hydra-projectile
  (:color teal :hint nil)
  "
  PROJECTILE: %(projectile-project-root)

  ^Find File^        ^Search/Tags^        ^Buffers^         ^Cache^                      ^Project^
  ^---------^        ^-----------^        ^-------^         ^-----^                      ^-------^
  _f_: file          _R_: grep            _i_: Ibuffer      _c_: cache clear             _p_: switch proj
  _F_: file dwim     _g_: update gtags    _b_: switch to    _x_: remove known project
  _C-f_: file pwd    _o_: multi-occur     _s-k_: Kill all   _X_: cleanup non-existing
  _r_: recent file   ^ ^                  ^ ^               _z_: cache current
  _d_: dir
"
  ("R"   counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   counsel-projectile-find-dir)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-dwim)
  ("C-f" projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("p"   counsel-projectile-switch-project)
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("q"   nil "cancel" :color blue))

(bind-key "C-c p" #'hydra-projectile/body)
#+END_SRC
*** Visual Regexp
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure nil
  :commands (vr/replace vr/query-replace))
#+END_SRC
*** Screencast
#+BEGIN_SRC emacs-lisp
(autoload 'gif-screencast "gif-screencast" "Start GIF Screencast" t)
(autoload 'keycast-mode "keycast" "Start `keycast-mode'" t)

(defun og/begin-screencast ()
  (interactive)
  (gif-screencast)
  (unless (bound-and-true-p keycast-mode) (keycast-mode)))

(defun og/end-screencast ()
  (interactive)
  (gif-screencast-stop)
  (when (bound-and-true-p keycast-mode) (keycast-mode)))

(bind-key "<f8>" #'og/begin-screencast)
(bind-key "<f9>" #'og/end-screencast)
#+END_SRC
*** Key Frequency
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :defer 3
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  :custom
  (keyfreq-file "~/.emacs-keyfreq"))
#+END_SRC
*** El-patch
Properly patch functions.
#+BEGIN_SRC emacs-lisp
(use-package el-patch
  :commands (el-patch-defun))
#+END_SRC
*** Transmission
Simple client for =transmission-cli=.
#+BEGIN_SRC emacs-lisp
(use-package transmission
  :commands (transmission transmission-add)
  :config (add-to-list 'transmission-refresh-modes 'transmission-mode)
  :bind (:map transmission-mode-map
              ("T" . transmission-toggle-limits)))
#+END_SRC
I often want to download large torrents to my external drive if possible.
#+BEGIN_SRC emacs-lisp
(defun og/transmission-add (url)
  (let* ((torrent-dir-cand (expand-file-name "download" og--drive-path))
         (torrent-dir (when (file-directory-p torrent-dir-cand) torrent-dir-cand)))
  (transmission-add url torrent-dir)))
#+END_SRC
*** Spray
Spray is a speed-reading package for Emacs.
#+BEGIN_SRC emacs-lisp
(use-package spray
  :hook ((spray-mode . (lambda () (beacon-mode -1)))
         (spray-mode . olivetti-mode))
  :custom
  (spray-margin-top 5)
  (spray-margin-left 1.5))
#+END_SRC
*** Togetherly
#+BEGIN_SRC emacs-lisp
(use-package togetherly
  :commands (togetherly-server-start togetherly-client-start))
#+END_SRC
* Keybindings
** Better Defaults
These are what I think are better bindings for or better versions of the default
commands.
*** Easy M-x
Alt is simply too hard to hit for such a commonly used command.
#+BEGIN_SRC emacs-lisp
(bind-key "C-SPC" #'execute-extended-command)
#+END_SRC
*** Set Mark
Need a replacement because we rebound ~C-SPC~ above. And I know, I know, everyone
loves =transpose-chars=, but I don't see myself using it that much.
#+BEGIN_SRC emacs-lisp
(bind-key "C-t" #'set-mark-command)
#+END_SRC
*** Shell Kill Word
Use the standard Unix shell binding for deleting the previous word. As a result,
it's fine to remove the default Emacs bindings for this. In fact,
=C-<backspace>= in particular can get in the way.
#+BEGIN_SRC emacs-lisp
(bind-key "C-w" #'backward-kill-word)
(unbind-key "C-<backspace>")
(unbind-key "M-DEL")
#+END_SRC
*** Kill Paragraph
This binding takes after the default =M-k= binding for =kill-sentence=.
#+BEGIN_SRC emacs-lisp
(bind-key "M-K" #'kill-paragraph)
#+END_SRC
*** Browse Kill Ring
This used to be a feature of Emacs.
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring
  :bind ("M-y" . browse-kill-ring)
  :config (browse-kill-ring-default-keybindings))
#+END_SRC
*** Unfill Paragraph
I used to =[remap fill-paragraph]= to a function that toggled the paragraph from
filled to unfilled with a single key. It turned out this was not best for my use
case, as I usually double-tapped =M-q= because I just wanted to refill the
paragraph. However, unfilling is sometimes useful, so I kept the package around.
#+BEGIN_SRC emacs-lisp
(use-package unfill
  :commands unfill-paragraph
  :bind ("M-Q" . unfill-paragraph))
#+END_SRC
*** Join Line
This allows me to combine text over multiple lines into one line.
#+BEGIN_SRC emacs-lisp
(defun og/join-line ()
  (interactive)
  (join-line -1))

(bind-key "M-j" #'og/join-line)
#+END_SRC
*** Normal Undo Binding
#+BEGIN_SRC emacs-lisp
(bind-key "C-z" 'undo)
(bind-key "C-x C-u" 'undo)
#+END_SRC
*** Better Narrowing
From [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim]].
#+BEGIN_SRC emacs-lisp
(defun narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(bind-key "n" #'narrow-or-widen-dwim ctl-x-map)
#+END_SRC
Then we can use =narrow-or-widen-dwim= to easily edit org =src= blocks.
#+BEGIN_SRC emacs-lisp
(after! org-src
  (bind-key "C-x C-s" #'org-edit-src-exit org-src-mode-map))
#+END_SRC
*** Delete Better
When using =C-d= or =Backspace=, delete all white space in a certain direction, and
not just one.
#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :commands hungry-delete-mode
  :hook (text-mode . hungry-delete-mode))
#+END_SRC
*** Better Buffers
Kill better.
#+BEGIN_SRC emacs-lisp
(defun bjm/kill-this-buffer ()
  (interactive)
  (kill-buffer (current-buffer)))

(bind-key "C-x k" 'bjm/kill-this-buffer)
#+END_SRC
Exterminate better.
#+BEGIN_SRC emacs-lisp
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (kill-buffer buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(bind-key "C-x C-k" #'delete-current-buffer-file)
#+END_SRC
Rename better (from Magnar Sveen).
#+BEGIN_SRC emacs-lisp
(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file." name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(bind-key "C-x C-r" #'rename-current-buffer-file)
#+END_SRC
Switch better.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x b" #'ivy-switch-buffer)
#+END_SRC
Use =ibuffer=.
#+BEGIN_SRC emacs-lisp
(autoload 'ibuffer "ibuffer" "List buffers." t)
(bind-key "C-x C-b" 'ibuffer)
#+END_SRC
*** Unbind Fill Column
I never use this command but keep accidentally hitting it instead of =C-x C-f=.
#+BEGIN_SRC emacs-lisp
(unbind-key "C-x f")
#+END_SRC
*** Delete Frame
The default =C-x 5 0= is too clunky for this.
#+BEGIN_SRC emacs-lisp
(bind-key "C-x w" #'delete-frame)
#+END_SRC
*** Comment Dwim
A better version of the built-in =comment-dwim= from [[https://github.com/remyferre/comment-dwim-2][remyferre/comment-dwim-2]].
#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :commands comment-dwim-2
  :bind (("M-;" . comment-dwim-2)))
#+END_SRC
** Keychord
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package key-chord
  :ensure nil
  :demand t
  :config
  (key-chord-mode 1)
  <<keychord>>)
#+END_SRC
*** Number Symbols
Eliminate the shift key for inputting symbols. The dollar sign ($) keychord is
especially useful when typing LaTeX.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref keychord
(key-chord-define-global "1q" "!")
(key-chord-define-global "2w" "@")
(key-chord-define-global "3e" "#")
(key-chord-define-global "4r" "$")
(key-chord-define-global "5t" "%")
(key-chord-define-global "6y" "^")
(key-chord-define-global "6t" "^")
(key-chord-define-global "7y" "&")
(key-chord-define-global "8u" "*")
(key-chord-define-global "9i" "(")
(key-chord-define-global "0o" ")")
(key-chord-define-global "-p" "_")
(key-chord-define-global "[=" "+")
#+END_SRC
** Toggles
We use a hydra to toggle various features in our setup. I bind the keys in my
section for the [[*Context-dependent Hydra][Context-dependent Hydra]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-toggle (:color pink)
  "
_t_ theme-colour       %`og/theme
_m_ quick-math-mode:   %`quick-math-mode
_p_ equation-preview:  %`og/eq-preview-mode
_e_ pretty-math:       %`pretty-math-mode
_D_ dubcaps-mode:      %`og/dubcaps-mode
_W_ Window management
"
  ("t" og/switch-theme nil)
  ("m" quick-math-mode nil :color blue)
  ("p" og/eq-preview-mode nil)
  ("e" pretty-math-mode nil)
  ("D" og/dubcaps-mode nil)
  ("W" hydra-window-mnog/body :color blue)
  ("q" nil "cancel"))
#+END_SRC
I also link to window management here.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defun shrink-frame-horizontally (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-width frame (- (frame-width frame) increment))))
(defun enlarge-frame-horizontally (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-width frame (+ (frame-width frame) increment))))
(defun shrink-frame-vertically (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-height frame (- (frame-height frame) increment))))
(defun enlarge-frame-vertically (&optional increment)
  (interactive "p")
  (let ((frame (window-frame)))
    (set-frame-height frame (+ (frame-height frame) increment))))

(defun shift-frame-right (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'left (+ (frame-parameter nil 'left) increment)))
(defun shift-frame-left (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (message "user-pos:" (frame-parameter nil 'user-position))
  (set-frame-parameter nil 'left (- (frame-parameter nil 'left) increment)))
(defun shift-frame-up (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'top (- (frame-parameter nil 'top) increment)))
(defun shift-frame-down (&optional increment)
  (interactive "P")
  (unless increment (setq increment 20))
  (set-frame-parameter nil 'top (+ (frame-parameter nil 'top) increment)))

(defhydra hydra-window-mngm (:color pink :hint nil)
  "
frame    ^ ^ _i_ ^ ^    frame   ^ ^ _z_ ^ ^    window   ^ ^ _w_
sizing:  _j_ ^ ^ _l_    moving: _g_ ^ ^ _h_    sizing:  _a_ ^ ^ _s_
         ^ ^ _k_ ^ ^            ^ ^ _b_ ^ ^             ^ ^ _y_
"
  ("a" shrink-window-horizontally)
  ("s" enlarge-window-horizontally)
  ("y" enlarge-window)
  ("w" shrink-window)
  ("j" shrink-frame-horizontally)
  ("l" enlarge-frame-horizontally)
  ("k" shrink-frame-vertically)
  ("i" enlarge-frame-vertically)
  ("g" shift-frame-left)
  ("h" shift-frame-right)
  ("z" shift-frame-up)
  ("b" shift-frame-down)
  ("q" nil "quit" :color blue))
#+END_SRC
* Org Mode
We have to require the entire =org.el= file to get ~ox-hugo~ to work properly.
#+BEGIN_SRC emacs-lisp :noweb no-export
(after! org
  <<org-settings>>
  (bind-keys :map org-mode-map
             <<org-keys>>))
#+END_SRC
** Configuration
*** Speed Keys
This mode binds Org Mode commands to single character sequences, as long as you
are at the beginning of an Org headline.
#+BEGIN_SRC emacs-lisp
(setq org-use-speed-commands t)
#+END_SRC
We customize the commands a bit.
#+BEGIN_SRC emacs-lisp
(setq org-speed-commands-user
      '(("j" counsel-org-goto)
        ("a" org-archive-subtree)
        ("c" org-set-tags-command)
        ("d" (lambda () (interactive) (org-todo 'done)))))
#+END_SRC
This isn't quite speed keys, but I'm adding back the functionality of expanding
=<s= into a source block (and =<l= into a LaTeX block, and so on) that was changed
in Org >=9.2.
#+BEGIN_SRC emacs-lisp
(require 'org-tempo)
#+END_SRC
*** Invisible Edits
When text is entered near a hidden area (...), it is hard to see what is
changed.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-catch-invisible-edits 'show-and-error)
#+END_SRC
*** Better Return Behaviour
A better return for Org mode. If in a list, we want to add a new item.
If we're in a heading, we want to go the end of the line, then return. This is
because I never want to split the heading in half. If we're in a table, we add a
new row. If we are in a source block, we want to indent. Inspired by [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][John Kitchin]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun og/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond
     ((eq 'link (car (org-element-context)))
      (org-return))
     ((and (org-in-item-p) (not (bolp)))
      (if (org-element-property :contents-begin (org-element-context))
          (org-insert-item)
        (beginning-of-line)
        (cl--set-buffer-substring (line-beginning-position) (line-end-position) "")
        (org-return)))
     ((org-at-heading-p)
      (end-of-line)
      (org-return))
     ((org-at-table-p)
      (if (-any?
           (lambda (x) (not (string= "" x)))
           (nth
            (- (org-table-current-dline) 1)
            (org-table-to-lisp)))
          (org-return)
        ;; empty row
        (beginning-of-line)
        (cl--set-buffer-substring (line-beginning-position) (line-end-position) "")
        (org-return)))
     ((org-in-src-block-p)
      (newline-and-indent))
     (t
      (org-return)))))
#+END_SRC
We replace the normal return.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "RET" #'og/org-return org-mode-map)
(bind-key "C-RET" #'org-return org-mode-map)
#+END_SRC
*** Refile and Archival
Log refiling.
#+BEGIN_SRC emacs-lisp
(setq org-log-refile 'time)
#+END_SRC
Don't refile to DONE tasks.
#+BEGIN_SRC emacs-lisp
(defun og/verify-refile-target ()
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'og/verify-refile-target)
#+END_SRC
Cache the refile targets. It can be refreshed with =C-u C-u C-u C-u C-w=.
#+BEGIN_SRC emacs-lisp
(setq org-refile-use-cache t)
#+END_SRC
Refile to a given location.
#+BEGIN_SRC emacs-lisp
(defun og/refile (file headline)
  (let ((curr-buff (buffer-name))
        (pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (org-refile nil nil (list headline file nil pos))
    (switch-to-buffer curr-buff)))
#+END_SRC
I often have a bunch of files I need to organize, such as scanned papers or
documents sitting in my downloads folder. Invoking =org-attach= from each target
is a lot of tedious work, so I made this snippet that lets me do it all from a
Dired buffer.
#+BEGIN_SRC emacs-lisp
(defun og--attach-name (file title)
  (concat (replace-regexp-in-string " " "-" (downcase title)) "." (f-ext file)))

(defun og--attach-to-subtree (file &optional new-filename rfloc)
  (unless rfloc (setq rfloc (org-refile-get-location nil nil t)))
  (unless new-filename (setq new-filename (og--attach-name file (read-string "Title: "))))
  (let* ((target (nth 1 rfloc))
        (mark-maybe (nth 3 rfloc))
        (mark (if (markerp mark-maybe)
                  (marker-position mark-maybe)
                mark-maybe))
        (new-file (expand-file-name new-filename (f-dirname file)))
        (old-buff (current-buffer))
        title)
    (condition-case nil
        (rename-file file new-file)
      (error nil))
    (find-file target)
    (goto-char mark)
    (org-attach-attach new-file)
    (switch-to-buffer old-buff)))

(defun og/dired-attach-files ()
  (interactive)
  (let ((list (dired-get-marked-files)))
    (delete-other-windows)
    (find-file-other-window (dired-file-name-at-point))
    (other-window 1)
    (while list
      (org-refile 0)
      (other-window 1)
      (delete-window)
      (find-file-other-window (dired-file-name-at-point))
      (when (eq major-mode 'pdf-view-mode)
        (pdf-view-first-page))
      (other-window 1)
      (og--attach-to-subtree (dired-file-name-at-point))
      (!cdr list)
      (when list
        (dired-next-marked-file 1)))))
#+END_SRC
[[https://orgmode.org/worg/org-hacks.html#org0344577][Worg]] gives a way to avoid messing up the heading hierarchy of an archive file
after archiving lower level items.
#+BEGIN_SRC emacs-lisp
(defun og/org-inherited-no-file-tags ()
  (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
        (ltags (org-entry-get nil "TAGS")))
    (mapc (lambda (tag)
            (setq tags
                  (replace-regexp-in-string (concat tag ":") "" tags)))
          (append org-file-tags (when ltags (split-string ltags ":" t))))
    (if (string= ":" tags) nil tags)))

(defadvice org-archive-subtree (around my-org-archive-subtree-low-level activate)
  (let ((tags (og/org-inherited-no-file-tags))
        (org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it
    (with-current-buffer (find-file-noselect (org-extract-archive-file))
      (save-excursion
        (while (org-up-heading-safe))
        (org-set-tags-to tags)))))
#+END_SRC
I keep accidentally archiving subtrees.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(unbind-key "C-c C-x C-s" org-mode-map)
#+END_SRC
*** Capture
:PROPERTIES:
:ORDERED:  t
:END:
Org Capture is one of the best features of Org Mode. I use it to organize my
todo list, take note of ideas I think of, and kickstart blog posts.
#+BEGIN_SRC emacs-lisp
(bind-key "C-c c" #'org-capture)
#+END_SRC
I want to start captures in new frames.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-capture-pop-frame)
#+END_SRC
Here are my capture templates.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-capture-templates
      `(("a" "Appointment" entry
         (file ,(expand-file-name "gcal.org" org-directory))
         "* %^{Title} \n%^T\n"
         :immediate-finish t)
        ("t" "Todo" entry
         (file org-default-notes-file)
         "* TODO %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("n" "Note" entry
         (file org-default-notes-file)
         "* %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:END:\n%i%?")
        ("j" "Journal" entry
         (file+olp+datetree ,(expand-file-name "journal.org" org-directory))
         "** %^{Heading}\n:PROPERTIES:\n:CREATED: %U\n:END:")
        ("e" "euler" entry
         (file+headline "~/website/content-org/blog.org" "Euler")
         "** Project Euler %^{Problem Number}: %^{Problem Name} %^g
:PROPERTIES:
:EXPORT_FILE_NAME: %\\1
:EXPORT_DATE: %u
:EXPORT_DESCRIPTION: My solution to problem %\\1 of Project Euler.
:END:\n*** Problem Statement\n%?\n*** My Algorithm")))
#+END_SRC
The two applications I spend the most time in are Emacs and the browser (I use
qutebrowser). It would be very nice if I could use Org Capture from within the
web browser. In particular, I want to be able to rely on the functionality of
Org Mode to manage my bookmarks (see [[https://karl-voit.at/2014/08/10/bookmarks-with-orgmode/][Karl Volt's method]]), rather than rely on
the browser. Also, I often come across quotes or excerpts that I'd love to file
away for later. The built-in =org-protocol= lets us intercept calls to =emacsclient=
from a web browser and apply functions to it, like =org-capture=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol)
#+END_SRC
However, this only lets us manipulate the selection in the browser as plain
text. Pretty much every browser has the ability to copy text as HTML. So we
leverage the power of =pandoc= to convert this HTML to Org Mode syntax using some
code by [[https://github.com/alphapapa/org-protocol-capture-html][alphapapa]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(require 'org-protocol-capture-html)
#+END_SRC
So how do we actually get data from the outside world into Emacs? The [[https://orgmode.org/worg/org-contrib/org-protocol.html][Org
Mode wiki]] has the basics. The meat of the following snippet is in the function
that turns the browser selection into HTML (after =&body==). It was sourced from
[[https://stackoverflow.com/questions/5643635/how-to-get-selected-html-text-with-javascript/6668159#6668159][StackOverflow]].
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://capture-html?template=p&url=' + encodeURIComponent(location.href) + '&title=' + encodeURIComponent(document.title || '[untitled page]') + '&body=' + encodeURIComponent(function () {var html = ''; if (typeof document.getSelection != 'undefined') {var sel = document.getSelection(); if (sel.rangeCount) {var container = document.createElement('div'); for (var i = 0, len = sel.rangeCount; i < len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != 'undefined') {if (document.selection.type == 'Text') {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement('a'); a.href = href; var abs = a.protocol + '//' + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [['a', 'href'], ['img', 'src']]; var div = document.createElement('div'); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i < elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}());
#+END_SRC
I bind this to =c b=, for "capture bookmark." The data goes to the following template.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(add-to-list
 'org-capture-templates
 '("p" "Org Protocol" entry
   (file org-default-notes-file)
   "* %^{Title|%(og/square-to-round-brackets \"%:description\")} :web:
:PROPERTIES:
:CREATED: %U
:SOURCE: [[%:link][%(og/square-to-round-brackets \"%:description\")]]
:END:
%?\n%(->> \"%i\" og/fix-mathjax-output og/quote-if-non-empty)"))
#+END_SRC
Because Org links are constructed with square brackets, any URL whose title
contains square brackets (I'm looking at you, arXiv) would break a normal
implementation of the this template. Our workaround is to change square brackets
to round ones.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun og/square-to-round-brackets (s)
  "Transform [ into ( and ] into ), other chars left unchanged."
  (->> s
      (replace-regexp-in-string "\\[" "\(")
      (replace-regexp-in-string "\\]" "\)")))
#+END_SRC
Also, I want to wrap the excerpt in an Org quote block, but not if there is no
excerpt.
#+BEGIN_SRC emacs-lisp
(defun og/quote-if-non-empty (str)
  (setq str (with-temp-buffer
              (insert (s-trim str))
              (fill-region (point-min) (point-max))
              (buffer-string)))
  (unless (or (string-blank-p str) ;; dont quote things with headings or org blocks
              (string-match-p "\\(^ \\**\\)\\|\\(#\\+BEGIN_\\)" str))
    (setq str (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" str)))
  (s-trim str))
#+END_SRC
Copying MathJax is a little strange. It pastes in the form =A$B$$B'$=, where =A=
contains no spaces and is a Unicode representation of the LaTeX string, and =B=
and =B'= are slight variants of the actual LaTeX string. I'm not quite certain
what the differences between =B= and =B'= are. They both seem to be functional, but
=B'= generally seems to be better. For example, =B= might contain =a^{n}= and =\lbrack 0,1
\rbrack=, while =B'= has =a^n= and =[0,1]=. This function runs a simple regex replace
for =B'=.
#+BEGIN_SRC emacs-lisp
(defun og/fix-mathjax-output (str)
  (let ((re "[^ $]*\$[^$]*\$\$\\([^$]*\\)\\$"))
    (replace-regexp-in-string re "\\\\(\\1\\\\)" str)))
#+END_SRC
I also bind =c l= to store the URL of the current page as an Org link.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://store-link:?url='+encodeURIComponent(location.href)
#+END_SRC
Finally, I have a general purpose binding on =c n= for capturing any notes or
thoughts that come to me while browsing.
#+BEGIN_SRC js :tangle no
javascript:location.href='org-protocol://capture?template=n'
#+END_SRC
I bind =c p= as a specific case of =c b= for PDF files. The following function
fetches the path of the current PDF file in qutebrowser's temporary download directory.
#+BEGIN_SRC emacs-lisp
(defun og/find-qutebrowser-download-dir (url)
  (expand-file-name
   (car
    (cl-loop for dir in (directory-files "/tmp/")
             when (string-match "qutebrowser-downloads" dir)
             collect dir))
   "/tmp"))

(defun og/find-qutebrowser-download (url)
  (let* ((file (progn (string-match "\\(tmp.*\\.pdf\\)" url)
                      (substring url (match-beginning 1) (match-end 1))))
         (qutedir (og/find-qutebrowser-download-dir url))
         (dldir "~/Downloads/")
         (src (expand-file-name file qutedir))
         (dst (expand-file-name file dldir)))
    (unless (file-exists-p dst)
      (rename-file src dst))
    dst))
#+END_SRC
This template attaches the file for future reference.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(add-to-list
 'org-capture-templates
 '("q" "Org Protocol Qutebrowser pdf" entry
   (file org-default-notes-file)
   "* %^{Title} %(let* ((dir \"~/org/data\") (org-attach-directory dir)) (require 'org-attach)
(org-attach-attach (og/find-qutebrowser-download \"%:description\") nil 'cp) \"\")\n:PROPERTIES:\n:CREATED: %U %^{Author}p\n:END:\n%?\n"))
#+END_SRC
*** Org Download
Now we can easily move images into Org Mode buffers.
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :commands (org-download-yank)
  :config
  (org-download-enable)
  :custom
  (org-download-method 'attach)
  (org-download-timestamp t) (org-download-screenshot-method "scrot -s"))
#+END_SRC
**** Add Images to Notes Live
[[http://pragmaticemacs.com/emacs/a-workflow-to-quickly-add-photos-to-org-mode-notes/][This article]] gives a neat way to add images taken from your phone into an Org
Mode buffer. This could be useful if you are taking notes in a class or
conference and want to reference a slide or diagram on the board.

I use Syncthing to get photos from my phone to my computer, but any syncing
service works, like Google Drive or Dropbox.
#+BEGIN_SRC emacs-lisp
(defvar og/live-image-dir (expand-file-name "~/Camera/Camera"))
#+END_SRC
We use =ivy= to prompt the user for a file from the camera roll, sorted by most
recent. Then, we attach the file to the current subtree by /copying/ it, add an
image link, and display it. Because most images taken this way are vertical, I
rotate the image first to make sure it displays correctly.
#+BEGIN_SRC emacs-lisp
(defun og/insert-live-image ()
  (interactive)
  (let (file-list file-list-sorted start-file start-file-full end-file)
    (setq file-list
          (-remove (lambda (x) (nth 1 x))
                   (directory-files-and-attributes og/live-image-dir)))
    (setq file-list-sorted
          (mapcar #'car
                  (sort file-list
                        #'(lambda (x y) (time-less-p (nth 6 y) (nth 6 x))))))
    (setq start-file (ivy-read
                      "Select file to attach:"
                      file-list-sorted
                      :re-builder #'ivy--regex
                      :sort nil
                      :initial-input nil))
    (setq start-file-full
          (expand-file-name start-file og/live-image-dir))
    (org-attach-attach start-file-full nil 'cp)
    (message "Attached %s" start-file-full)
    (setq end-file (expand-file-name start-file (org-attach-dir nil)))
    (call-process "convert" nil nil nil end-file "-rotate" "-90" end-file)
    (insert (org-link-make-string (format "file:%s" end-file)))
    (org-display-inline-images t t)))
#+END_SRC
*** Todo Lists
I like the following set of =TODO= words. This is what appears
before an Org headline when a todo state is activated.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-keywords
      '((sequence "TODO(t!)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC
Automatically archive cancelled tasks.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-todo-state-tags-triggers '(("CANCELLED" ("ARCHIVE" . t))))
#+END_SRC
Track when a heading is added already in TODO state.
#+BEGIN_SRC emacs-lisp
(setq org-trest-insert-todo-heading-as-state-change t)
#+END_SRC
Track the time when a TODO item is marked DONE.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-log-done 'time)
#+END_SRC
Do something similar for other properties.
#+BEGIN_SRC emacs-lisp
(setq org-log-reschedule 'time
      org-log-redeadline 'time
      org-log-clock-out 'time)
#+END_SRC
Because I make a lot of logs, I want to file them away into the LOGBOOK drawer.
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC
I would rather the progress in a todo list (for example, [4/5]) be automatically
updated when I archive a subtree.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-archive-subtree (after fix-cookies activate)
  (myorg-update-parent-cookie))
#+END_SRC
If all the checkboxes in a list are checked, the parent heading is done, and its
TODO state should be marked as such.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'org-list
  '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))

(defun ndk/checkbox-list-complete ()
  (save-excursion
    (org-back-to-heading t)
    (let ((beg (point)) end)
      (end-of-line)
      (setq end (point))
      (goto-char beg)
      (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    ;; all done - do the state change
                    (org-todo 'done)
                  (org-todo 'todo))
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (org-todo 'done)
                (org-todo 'todo)))))))
#+END_SRC
I've never used these commands on purpose.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(unbind-key "C-c [" org-mode-map)
#+END_SRC
*** Links
I often use links to easily navigate to a relevant file in cases where I would
rather not use =org-attach=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c l" . org-store-link)
#+END_SRC
Follow links using return rather than =C-c C-o=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-return-follows-link t)
#+END_SRC
I can use =org-cliplink= to paste in a website's URL with the link's description
being the title of that website.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-cliplink
  :commands org-cliplink
  :bind (:map org-mode-map ("C-c y" . org-cliplink)))
#+END_SRC
*** Word Count
#+BEGIN_SRC emacs-lisp
(use-package org-wc
  :commands org-wc-display
  :bind (:map org-mode-map ("C-c w" . org-wc-display)))
#+END_SRC
*** Org Ref
A wonderfully featured framework for maintaining bibliographies and writing
academic papers in Org Mode by Org-guru John Kitchin.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package org-ref)
(setq org-ref-completion-library 'org-ref-ivy-cite)
(autoload #'org-ref-insert-link "org-ref")
(autoload #'org-ref-bibtex-new-entry/body "org-ref")
(add-hook 'bibtex-mode-hook (lambda () (require 'org-ref)))
(after! org-ref
  (require 'doi-utils)
  (require 'org-ref-pdf)
  (bind-key "C-c b" #'biblio-arxiv-lookup bibtex-mode-map)
  <<org-ref>>)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq bibtex-default-files '("~/texmf/bibtex/bib/main.bib"))

(defun og/update-bib-files ()
  (setq bibtex-completion-bibliography
              (delete-dups (append
                            bibtex-default-files
                            (directory-files default-directory nil "\\.bib$")))))
(add-hook 'org-mode-hook #'og/update-bib-files)
#+END_SRC
For humanities essays.
#+BEGIN_SRC emacs-lisp
(defun og/org-ref-cite-with-page ()
  (interactive)
  (if current-prefix-arg
      (call-interactively #'org-ref-insert-link)
    (insert "[[")
    (call-interactively #'org-ref-insert-link)
    (insert "][")
    (insert (read-string "Page number: "))
    (insert "]] ")))
#+END_SRC
Bind this in Org Mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(bind-key "C-c ]" #'org-ref-insert-link org-mode-map)
(bind-key "C-c }" #'org-ref-insert-ref-link org-mode-map)
#+END_SRC
Use =ivy= instead of =helm= for =org-ref= completion. It makes everything more
cohesive, as I use =ivy= everywhere else.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq org-ref-completion-library 'org-ref-ivy-cite)
#+END_SRC
Whether it's side citations or footnotes, I almost always use the =\footcite=
macro in LaTeX.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq org-ref-default-citation-link "cite")
#+END_SRC
It's >=2019. BibTeX is a thing of the past.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq bibtex-dialect 'biblatex)
#+END_SRC
Format the automatically generated keys.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC
I'm not entirely sure what this file does or how useful it is, but I didn't want
it cluttering up my home directory.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-ref
(setq orhc-bibtex-cache-file (expand-file-name ".orhc-bibtex-cache" gmacs-cache-dir))
#+END_SRC
Redefine: Small modification to how files are attached to bib entries. I want the default
directory to be my downloads folder.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (defun org-ref-bibtex-assoc-pdf-with-entry (&optional prefix)
    "Prompt for pdf associated with entry at point and rename it.
Check whether a pdf already exists in `org-ref-pdf-directory' with the
name '[bibtexkey].pdf'. If the file does not exist, rename it to
'[bibtexkey].pdf' using
`org-ref-bibtex-assoc-pdf-with-entry-move-function' and place it in
`org-ref-pdf-directory'. Optional PREFIX argument toggles between
`rename-file' and `copy-file'."
    (interactive "P")
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((file (read-file-name "Select file associated with entry: " "~/Downloads"))
             (bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (concat org-ref-pdf-directory (concat key ".pdf")))
             (file-move-func (org-ref-bibtex-get-file-move-func prefix)))
        (if (file-exists-p pdf)
            (message (format "A file named %s already exists" pdf))
          (progn
            (funcall file-move-func file pdf)
            (message (format "Created file %s" pdf))))))))
#+END_SRC
Redefine to also check the file given in the bib entry.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (defun org-ref-open-bibtex-pdf ()
  "Open pdf for a bibtex entry, if it exists.
assumes point is in
the entry of interest in the bibfile.  but does not check that."
  (interactive)
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (funcall org-ref-get-pdf-filename-function key))
           (pdf2 (reftex-get-bib-field "file" entry)))
      (if (file-exists-p pdf)
          (org-link-open-from-string (format "[[file:%s]]" pdf))
        (if (file-exists-p pdf2)
            (org-link-open-from-string (format "[[file:%s]]" pdf2))
          (ding)))))))
#+END_SRC
Use the label names I make, which allows me to access them before export, at the
risk of them not being unique.
#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC
*** Context-dependent Hydra
#+BEGIN_SRC emacs-lisp
(defun og/context-hydra-launcher ()
  "A launcher for hydras based on the current context."
  (interactive)
  (require 'org-link-edit)
  (if current-prefix-arg
      (hydra-toggle/body)
    (cl-case major-mode
      ('org-mode (let* ((elem (org-element-context))
                        (etype (car elem))
                        (type (org-element-property :type elem)))
                   (cl-case etype
                     (src-block (hydra-babel-helper/body))
                     (link (hydra-org-link-helper/body))
                     ((table-row table-cell) (hydra-org-table-helper/body) )
                     (t (message "No specific hydra for %s/%s" etype type)
                        (hydra-toggle/body)))))
      ('bibtex-mode (org-ref-bibtex-hydra/body))
      (t (message "No hydra for this major mode: %s" major-mode)))))

(bind-key "C-c t" 'og/context-hydra-launcher)
#+END_SRC
**** Links
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
;; (setq hydra-org-link-helper-hint-base
;;       "
;; org link helper
;; _i_ backward slurp     _o_ forward slurp    _n_ next link
;; _j_ backward barf      _k_ forward barf     _p_ previous link

;; _q_ quit
;; ")

;; (defhydra hydra-org-link-helper (:color pink)
;;   hydra-org-link-helper-hint-base
;;   ("i" org-link-edit-backward-slurp)
;;   ("o" org-link-edit-forward-slurp)
;;   ("j" org-link-edit-backward-barf)
;;   ("k" org-link-edit-forward-barf)
;;   ("n" org-next-link)
;;   ("p" org-previous-link)
;;   ("q" nil :color blue))

;; (setq hydra-org-link-helper/hint
;;       '(if (equal (org-element-property :path (org-element-context)) "marginnote")
;;            (prog1
;;                (let* ((lines (split-string hydra-org-link-helper-hint-base "\n"))
;;                       (newhint "        _e_ shift margin note")
;;                       hint)
;;                  (setf (nth 2 lines) (concat (nth 2 lines) newhint))
;;                  (setq hint (mapconcat 'identity lines "\n"))
;;                  (eval
;;                   (hydra--format nil '(nil nil :hint nil)
;;                                  hint hydra-org-link-helper/heads)))
;;              (define-key hydra-org-link-helper/keymap "e"
;;                (lambda! ()
;;                         (og/math-make-marginnote-float)
;;                         (hydra-org-link-helper/nil))))
;;          (prog1
;;              (eval
;;               (hydra--format nil '(nil nil :hint nil)
;;                              hydra-org-link-helper-hint-base hydra-org-link-helper/heads))
;;            (define-key hydra-org-link-helper/keymap "e" nil))))
#+END_SRC
**** Tables
#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-table-helper (:color pink :hint nil)
  "
org table helper
_r_ recalculate     _w_ wrap region      _c_ toggle coordinates
_i_ iterate table   _t_ transpose        _D_ toggle debugger
_B_ iterate buffer  _E_ export table
_e_ eval formula    _s_ sort lines       _d_ edit field

_q_ quit
"
  ("E" org-table-export :color blue)
  ("s" org-table-sort-lines)
  ("d" org-table-edit-field)
  ("e" org-table-eval-formula)
  ("r" org-table-recalculate)
  ("i" org-table-iterate)
  ("B" org-table-iterate-buffer-tables)
  ("w" org-table-wrap-region)
  ("D" org-table-toggle-formula-debugger)
  ("t" org-table-transpose-table-at-point)
  ("c" org-table-toggle-coordinate-overlays :color blue)
  ("q" nil :color blue))
#+END_SRC
**** Source Blocks
#+BEGIN_SRC emacs-lisp
(defun og/org-babel-src-block-info ()
  (interactive)
  (if (get-buffer-window "*Help*")
      (delete-other-windows)
    (org-babel-view-src-block-info)))

(defhydra hydra-babel-helper (:color pink :hint nil)
  "
org babel src block helper functions
_n_ next       _i_ info           _h_ insert header
_p_ prev       _c_ check
_H_ goto head  _E_ expand
^ ^            _s_ split
_q_ quit       _r_ remove result  _e_ examplify region

"
  ("i" og/org-babel-toggle-src-block-info)
  ("h" org-babel-insert-header-arg)
  ("c" org-babel-check-src-block :color blue)
  ("s" org-babel-demarcate-block :color blue)
  ("n" org-babel-next-src-block)
  ("p" org-babel-previous-src-block)
  ("E" org-babel-expand-src-block :color blue)
  ("e" org-babel-examplify-region :color blue)
  ("r" org-babel-remove-result :color blue)
  ("H" org-babel-goto-src-block-head)
  ("q" nil :color blue))
#+END_SRC
*** Property Inheritance
We want it!
#+BEGIN_SRC emacs-lisp
(setq org-use-property-inheritance t
      org-attach-use-inheritance t)
#+END_SRC
** Prettifying
*** Headlines
Let's make our headings look a bit nicer. The package =org-bullet-mode= replaces the
asterisks that define an Org heading with pretty symbols, like stylized bullet
points.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(use-package org-superstar
    :commands org-superstar-mode
    :hook (org-mode . org-superstar-mode))
#+END_SRC
In a similar vein, it helps the visual hierarchy to have text indented in
accordance with the level of the heading, so I always use =org-indent-mode=.
Because it's always active, it's best to diminish it.
#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(diminish 'org-indent-mode)
#+END_SRC
The dot-dot-dot ellipsis that indicates hidden content can become a bit much
when you have a lot of headlines.
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⬎")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq org-startup-folded t)
#+END_SRC
*** Emphasis Markers
It looks much cleaner if we omit emphasis markers such as the =*= asterisks that
make something bold. It is enough to just display the argument as bold.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Lists
Have lists begun by, for example, =-= look like a bullet list.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(font-lock-add-keywords 'org-mode
                        '(("^ *\\([-]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
This doesn't change anything in the buffer, which is nice.
*** Pretty Symbols in Source Blocks
I do a lot of programming in Org Mode source blocks, and I want to have features
like =prettify-symbols-mode= for =lambda= functions in Elisp. However, this mode is
buffer local, so if I were to turn it on, I would have to display the string
"lambda" as "λ" throughout the buffer, even in paragraphs and the source blocks
of other languages. This is obviously undesirable.

We add hooks to particular languages to activate pretty symbols. In this case I
don't add the lambda fontification, just activate =pretty-symbols-mode=, because
the default variable =lisp-prettify-symbols-mode= already has this pair.
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq prettify-symbols-alist
                  '(("lambda" . ?λ)
                    ("lambda!" . (?λ (Br . Bl) ?!))))
            (prettify-symbols-mode)))
#+END_SRC
*** Inline Remote Images
Add the link type.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "image-url"
 (lambda (path)
   (let ((img (expand-file-name
           (concat (md5 path) "." (file-name-extension path))
           temporary-file-directory)))
     (if (file-exists-p img)
     (find-file img)
       (url-copy-file path img)
       (find-file img)))))
#+END_SRC
And the function to activate inlining.
#+BEGIN_SRC emacs-lisp
(defun image-url-overlays ()
  "Put image overlays on remote image urls."
  (interactive)
  (cl-loop for image-url in (org-element-map (org-element-parse-buffer) 'link
               (lambda (link)
                 (when (string= "image-url" (org-element-property :type link))
                   link)))
    do
    (let* ((path (org-element-property :path image-url))
           (ov (make-overlay (org-element-property :begin image-url)
                 (org-element-property :end image-url)))
           (img (create-image (expand-file-name
                   (concat (md5 path)
                       "."
                       (file-name-extension
                        path))
                   temporary-file-directory))))
      (overlay-put ov 'display img)
      (overlay-put ov 'image-url t))))

(defun image-url-clear-overlays ()
  "Reove overlays on image-urls."
  (interactive)
  (require 'ov)
  (ov-clear 'image-url))
#+END_SRC
** Babel
Set up languages loaded for use in Org source blocks and their respective
default execution commands.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(org-babel-do-load-languages
      'org-babel-load-languages '((python . t)
                                  (latex . t)
                                  (shell . t)))

(setq org-babel-python-command "python"
      org-babel-latex-command "pdflatex"
      org-babel-sh-command "sh")
#+END_SRC
Make Org Mode source blocks act normally with respect to indentation and syntax
highlighting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+END_SRC
I'm generally fine with just evaluating a code block.
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Proper Keymaps in Org Source Blocks
[[http://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/][John Kitchin]] explains how to get use keybindings from the appropriate language
major mode inside Org source blocks. This heavily reduces the need to activate
special edit mode with =C-c '=. The idea is that we set up keymaps and apply them
with font-lock by hooking into Org Mode's font-lock. We define the function that
applies the keymap to each block.
#+BEGIN_SRC emacs-lisp
(defun og/add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `og/src-block-keymaps'."
  (let ((case-fold-search t))
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) og/src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          og/src-block-keymaps))))))))))
#+END_SRC
To be able to toggle this, we add a minor mode. This is where we add the
relevant hook.
#+BEGIN_SRC emacs-lisp
(define-minor-mode og/src-keymap-mode
  "Minor mode to add mode keymaps to src-blocks."
  :init-value nil
  (if og/src-keymap-mode
      (progn
        (require 'elpy)
        (add-hook 'org-font-lock-hook #'og/add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map))
    (remove-hook 'org-font-lock-hook #'og/add-keymap-to-src-blocks)
    (cursor-sensor-mode -1))
  (call-interactively #'font-lock-fontify-buffer))
#+END_SRC
Here are the actual maps.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defvar og/src-block-keymaps
      `(("python" . ,(let ((map (make-composed-keymap
                                 `(,(when (boundp 'elpy-mode)
                                      elpy-mode-map)
                                   ,(when (boundp 'python-mode)
                                      python-mode-map))
                                 org-mode-map)))
                       ;; In org-mode I define RET so we redefine
                       (define-key map (kbd "RET") 'newline-and-indent)
                       (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                       map))
        ("emacs-lisp" . ,(let ((map (make-composed-keymap
                                     `(,emacs-lisp-mode-map)
                                     org-mode-map)))
                           (define-key map (kbd "RET") 'newline-and-indent)
                           (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                           map))))
#+END_SRC
** LaTeX
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-highlight-latex-and-related '(latex))
#+END_SRC
*** Math Mode
Define a keychord to enter inline math mode. This allows me to get around
messing with making =$= an electrically paired delimiter.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(after! key-chord
  (key-chord-define org-mode-map "r4" #'og/create-or-exit-math-fragment)
  (key-chord-define org-mode-map "df" #'og/create-or-exit-math-fragment))
#+END_SRC
**** Pretty Math Symbols
I got the source for this from [[https://bitbucket.org/mortiferus/latex-pretty-symbols.el][mortiferus]]. The file I use is not the one from
their Bitbucket repo; I have, for example, removed subscripts and superscripts.
#+BEGIN_SRC emacs-lisp
(require 'og-pretty-math)
#+END_SRC
*** Reformat Math Fragment
For my primary use case of typing math in LaTeX, I don't care about how the
source looks when I'm typing it; I'm often typing it live, so the main concern
is speed. But later, I want it to look nice and readable, with spacing and so
on.

The idea is pretty simple. We just maintain a list of regexps in
=og/reformat-fragment-alist= and run them all on a given LaTeX fragment with
=og/reformat-fragment=. The main thing to notice is that the regexp that takes
care of too many spaces goes last. This way, we don't have to worry about
introducing too many spaces in the earlier regexps.
#+BEGIN_SRC emacs-lisp
(defcustom og/reformat-fragment-alist
  '(("+" " + " "spaces around +")
    ("[ ]+\\([\\^_]\\)[ ]+" "\\1" "remove spaces around ^ and _")
    ("[\\^_]{}" "\\1" "remove empty sub/superscript and {} before them")
    ("{}^" "^" "remove {} before superscript")
    ("{}_" "_" "remove {} before superscript")
    (" +" " " "no more than 1 space in a row")
    ("\\(\\\\(\\) " "\\1" "no space at start of fragment")
    (" \\(\\\\)\\)" "\\1" "no space at end of fragment"))
  "Alist of (REGEXP TO DOCSTRING) parsed by `og/reformat-fragment'.
Upon reformatting, each REGEXP is replaced with TO. DOCSTRING
simply explains what the regexp does."
  :type 'alist
  :group 'quick-math)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun og/reformat-fragment (&optional fr)
  (let ((fr-type (car (if fr fr (org-element-context))))
        (fr-begin (if fr
                      (nth 1 fr)
                    (org-element-property :begin (org-element-context))))
        fr-end base)
    (goto-char fr-begin)
    (setq fr-end (- (org-element-property :end (org-element-context))
                    (org-element-property :post-blank (org-element-context))))
    (setq base (buffer-substring-no-properties fr-begin fr-end))
    (with-temp-buffer
      (dolist (reg og/reformat-fragment-alist)
        (setq base (replace-regexp-in-string (car reg) (nth 1 reg) base)))
      (insert base)
      (goto-char (point-min))
      (LaTeX-mode)
      (align-current)
      (setq base (buffer-substring-no-properties (point-min) (point-max)))
      (setq base (replace-regexp-in-string "& =" "&=" base)))
    (delete-region fr-begin fr-end)
    (insert base)
    (when (and (eq fr-type 'latex-environment)
               (eq (char-before) (string-to-char "}")))
      (newline))))
#+END_SRC
*** Change Bracket Sizes
This allows the user to easily change the size of brackets in LaTeX expressions.
#+BEGIN_SRC emacs-lisp
(autoload 'bratex-config "bratex")
(add-hook 'quick-math-mode-hook #'bratex-config)
#+END_SRC
*** Equation Auto Preview
:PROPERTIES:
:ORDERED:  t
:END:
functions from =ov.el=.
#+BEGIN_SRC emacs-lisp
(defun ov-at (&optional point)
  "Get an overlay at POINT.
POINT defaults to the current `point'."
  (or point (setq point (point)))
  (car (overlays-at point)))
#+END_SRC
Not too small.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.7))
#+END_SRC
Use my custom macros.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(when og/user
  (with-eval-after-load 'org
    (add-to-list 'org-latex-packages-alist '("" "og-math" t))))
#+END_SRC
Where should it be? Let's put them all in the same place, so that common
fragments (like =x^2=) are never generated more than once and so that we don't
litter our folders.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-preview-latex-image-directory
      (expand-file-name "cache/ltximg/" user-emacs-directory))
#+END_SRC
Use this instead of =org-latex-preview=.
#+BEGIN_SRC emacs-lisp
(require 'org-auctex)
;; (defun og/math-preview-toggle-subtree ()
;;   (interactive)
;;   (save-restriction
;;     (org-narrow-to-subtree)
;;       (if current-prefix-arg
;;           (math-preview--clear-region (point-min) (point-max))
;;         (math-preview--region (point-min) (point-max)))))

;; (use-package math-preview
;;   :commands (math-preview-at-point math-preview--region)
;;   :custom
;;   (math-preview-scale 1.1)
;;   (math-preview-margin '(0 . 0))
;;   (math-preview-raise 0.325)
;;   :config
;;   (add-to-list 'math-preview-tex-marks '("\\begin{align}"  "\\end{align}"))
;;   :bind (:map org-mode-map
;;               ("C-c C-x C-l" . 'og/math-preview-toggle-subtree)))
#+END_SRC
Inspired by John Kitchin. I've modified it to be toggleable and to run a hook on
leaving a math fragment.
#+BEGIN_SRC emacs-lisp
;; (defvar org-latex-fragment-last nil
;;   "Holds last fragment/environment you were on.")

;; (defun org-latex-fragment-toggle ()
;;   "Toggle a latex fragment image "
;;   (condition-case nil
;;       (and (eq 'org-mode major-mode)
;;            (let* ((begin (org-latex-fragment-in-latex-fragment-p)))
;;              (cond
;;               ;; were on a fragment and now on a new fragment
;;               ;; need to replace old image and clear current image
;;               ((and
;;                 org-latex-fragment-last
;;                 begin
;;                 (not (= begin
;;                         org-latex-fragment-last)))
;;                (org-latex-fragment-preview-last)
;;                (org-latex-fragment-clear begin))
;;               ;; were on a fragment and now are not on a fragment
;;               ;; need to replace old image
;;               ((and (not begin) org-latex-fragment-last)
;;                (org-latex-fragment-preview-last)
;;                (setq org-latex-fragment-last nil))
;;               ;; were not on a fragment and now are
;;               ((and (not org-latex-fragment-last) begin)
;;                (org-latex-fragment-clear begin))
;;               ;; else not on a fragment
;;               ((not begin)
;;                (setq org-latex-fragment-last nil)))))
;;     (error nil)))

;; (add-hook 'post-command-hook 'org-latex-fragment-toggle)
#+END_SRC
We can also centre equations and (this is useful when equation preview mode is
disabled) add a tooltip to them that lets you edit the equation when you click
on it. This is more John Kitchin code.
#+BEGIN_SRC emacs-lisp
;; (defun og/org-justify-fragment-overlay (beg end image imagetype)
;;   "Adjust the justification of a LaTeX fragment.
;; The justification is set by :justify in
;; `org-format-latex-options'. Only equations at the beginning of a
;; line are justified."
;;   (when
;;    ;; Centered justification
;;    (and (= beg (line-beginning-position))
;;          (string= "\\begin"
;;                   (buffer-substring-no-properties
;;                    beg (+ beg 6))))
;;     (let* ((img (create-image image 'png t))
;;            (width (car (image-size img)))
;;            (offset (floor (- (/ (min (window-max-chars-per-line) fill-column) 3) (/ width 3)))))
;;       (overlay-put (ov-at) 'before-string (make-string offset ? )))))

;; (defun og/org-latex-fragment-tooltip (beg end image imagetype)
;;   "Add the fragment tooltip to the overlay and set click function to toggle it."
;;   (overlay-put (ov-at) 'help-echo
;;                (concat (buffer-substring beg end)
;;                        "\nmouse-1 to toggle."))
;;   (overlay-put (ov-at) 'local-map (let ((map (make-sparse-keymap)))
;;                                     (define-key map [mouse-1]
;;                                       `())
;;                                     map)))

;; (advice-add 'org--format-latex-make-overlay :after 'og/org-justify-fragment-overlay)
;; (advice-add 'org--format-latex-make-overlay :after 'og/org-latex-fragment-tooltip)
#+END_SRC
Create a minor mode to preview equations. The keybinding is in [[*Toggles][a hydra]].
#+BEGIN_SRC emacs-lisp
(define-minor-mode og/eq-preview-mode
  "Preview equations."
  :init-value nil)

;; (defun og/eq-toggle ()
;;   (if og/eq-preview-mode
;;       (progn
;;         (add-hook 'post-command-hook 'org-latex-fragment-toggle t 'local))
;;     (remove-hook 'post-command-hook 'org-latex-fragment-toggle 'local)))

;; (add-hook 'og/eq-preview-mode-hook #'og/eq-toggle)
#+END_SRC
*** Allow Alphabetical List
#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC
*** Export
Remove "hypersetup" at the beginning of exported document.
#+BEGIN_SRC emacs-lisp
(setq org-latex-with-hyperref nil)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "tufte-org-mode/" gmacs-custom-dir))
(require 'ox-tufte-latex)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun og/org-latex-export ()
  (interactive)
  (save-excursion
    (while (and (not (org-entry-get (point) "EXPORT_FILE_NAME"))
                (not (string= (buffer-substring-no-properties
                               (line-beginning-position)
                               (min (point-max) (+ 2 (line-beginning-position))))
                              "* ")))
      (outline-up-heading 1 t))
    (when-let ((filebase (org-entry-get (point) "EXPORT_FILE_NAME")))
      (let* ((class (org-entry-get (point) "EXPORT_LATEX_CLASS"))
             (cmd (org-entry-get (point) "EXPORT_LATEX_CMD"))
             (file (replace-regexp-in-string "\\(\\.[^\\.]+\\)*$" ".tex" filebase))
             (processname (format "latex-export-%s-%s" (buffer-name) file)))
        (if (and class
                 (not (string= class "og-notes")))
            (org-latex-export-to-latex nil t)
          (org-tufte-latex-export-to-latex nil t))
        (unless (get-process processname)
          (async-start-process processname
                               "latexmk"
                               (lambda (file) (message (format "Exported %s" file)))
                               "-pdf"
                               "-pvc"
                               (if current-prefix-arg "-verbose" "-quiet")
                               "-interaction=nonstopmode"
                               file))
        (with-temp-file file
          (insert-file-contents file)
          (search-forward "\\end{document}")
          (previous-line)
          (end-of-line)
          (insert "\n\\hypersetup{urlcolor=Black}\n\\printbibliography")
          (search-backward "\\begin{document}")
          (beginning-of-line)
          (dolist (bibfile bibtex-completion-bibliography)
            (insert (format "\\addbibresource{%s}\n" bibfile)))
          (replace-regexp-in-region "\\\\cite\\[\\([^]]*\\)\\]\\[]" "\\\\cite[\\1]")
          (replace-regexp-in-region "\\\\label{sec:org[a-f0-9]+}\n" "")
          (replace-string-in-region "=_s" "=_\{\\mathrm\{s\}\}")
          (replace-string-in-region "\\sidenote[]" "\\sidenote")
          (replace-string-in-region "\\emph{Step " "\\step{Step ")
          (replace-string-in-region "e.g. " "e.g.~")
          (replace-string-in-region "i.e. " "i.e.~"))))))
#+END_SRC
Bind this in Org mode.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-keys
("C-c b" . og/org-latex-export)
#+END_SRC
Don't use straight quotes when exporting.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(setq org-export-with-smart-quotes t)
#+END_SRC
**** Math Macros
I have a LaTeX =.sty= file with macros for math. I want this to be automatically
included in every LaTeX file exported from Org Mode. The optional third argument
makes sure this package is also loaded when compiling LaTeX image previews, such
as equation previews.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(when og/user
  (setq org-latex-packages-alist
      '(("" "og-math" t))))
#+END_SRC
**** Command Links
:PROPERTIES:
:header-args: :tangle no :noweb-ref org-settings :results silent
:END:
No option.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\%s{%s}" path desc))))
#+END_SRC
One option.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s%s{%s}" path
                       (if (equal "" opt) opt (format "[%s]" opt))
                       arg)))))
#+END_SRC
One option, which goes afterwards.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "latex-opt-after"
 :follow nil
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (let* ((desc-list (split-string desc ";"))
                    (opt (nth 1 desc-list))
                    (arg (nth 0 desc-list)))
               (format "\\%s{%s}%s" path arg
                       (if (equal "" opt) opt (format "[%s]" opt)))))))
#+END_SRC
Todo link.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "todo"
 :follow nil
 :face '(:foreground "red" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\marginnote{\\textcolor{red}{\\textbf{TODO:}} %s}" path))))
#+END_SRC
Correction link.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "corr"
 :follow nil
 :face '(:foreground "medium sea green" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\textcolor{green}{%s}" path))))
#+END_SRC
Correction link.
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters
 "comment"
 :follow nil
 :face '(:foreground "dim gray" :underline t)
 :export (lambda (path desc format)
           (when (eq format 'latex)
             (format "\\textcolor{blue}{[%s]}" path))))
#+END_SRC
By default, Org Mode exports references to LaTeX with =\ref=. I prefer using the
=cleveref= package, which uses the =\cref= macro.
#+BEGIN_SRC emacs-lisp
(after! org-ref
  (org-link-set-parameters "ref"
                           :export
                           (lambda (label desc format)
                             (format "\\cref{%s}" label))))
#+END_SRC
**** Export Classes
#+BEGIN_SRC emacs-lisp
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("tufte-handout"
                 "\\documentclass{tufte-handout}
   [NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")))

  (add-to-list 'org-latex-classes
               '("og-notes"
                 "\\documentclass{og-notes}
[NO-DEFAULT-PACKAGES]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

  (add-to-list 'org-latex-classes
               '("amsart"
                 "\\documentclass[10pt, reqno]{amsart}
               [NO-DEFAULT-PACKAGES]
\\usepackage{og-amsart}"
                 ("\\section{%s}" . "\\section{%s}")
                 ("\\subsection{%s}" . "\\subsection{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection{%s}"))))
#+END_SRC
We make =amsart= our default class.
#+BEGIN_SRC emacs-lisp
(setq org-latex-default-class "amsart")
#+END_SRC
* Media
Here I configure everything for recreation and contact with the outside world:
managing email, consuming published media (blog posts and YouTube videos), and
listening to music.
** Mail
I used to use =mu4e=, but now I use =notmuch=. It has greater synergy with =elfeed=,
my RSS reader (in fact, =elfeed= was inspired by =notmuch=). Also, I found that =mu4e=
was too complicated and tried to do too much. As the name suggests, =notmuch=
doesn't have much. It's simple, transparent, and it works. That makes it perfect
for me.
#+BEGIN_SRC emacs-lisp :noweb no-export
(use-package notmuch
  :commands (notmuch notmuch-refresh-all-buffers)
  :config
  <<notmuch-settings>>
  :custom
  <<notmuch-custom-settings>>
  (nms-settings-file (expand-file-name "network-security.data" gmacs-cache-dir))
  :bind (:map notmuch-common-keymap
              ("g" . notmuch-refresh-this-buffer)
              ("G" . notmuch-refresh-all-buffers)
         :map notmuch-show-mode-map
              ("o" . ace-link-addr)))
#+END_SRC
Set up the mail directory and draft location.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-directory "~/mail/gmail"
      message-auto-save-directory "~/mail/gmail/drafts")
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq message-send-mail-function 'message-send-mail-with-sendmail)
(setq sendmail-program "gmi")
(setq message-sendmail-extra-arguments '("send" "--quiet" "-t" "-C" "~/mail/princeton"))
(setq notmuch-fcc-dirs nil)
(setq message-kill-buffer-on-exit t
      notmuch-address-command 'internal)
#+END_SRC
Show newest mail first.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-custom-settings
(notmuch-search-oldest-first nil)
#+END_SRC
Some commonly used searches.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key "i")
        (:name "unread" :query "tag:unread" :key "u")
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "s")
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a")))
#+END_SRC
Most modern mail clients expect mail to be soft-wrapped. That is, the paragraph
conforms to the width of the viewer the person reading the mail is using, not to
the sender's preference of 80 characters or whatever it may be. However, when
sending mail, I still want the buffer to look as if it was hard-wrapped. Enter
=visual-fill-column-mode=. This mode works with =visual-line-mode= to wrap the
paragraph not at the window edge but at =fill-column=.
#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode
  :hook (notmuch-message-mode . visual-fill-column-mode)
  :init
  (add-hook 'notmuch-message-mode-hook 'turn-off-auto-fill)
  (add-hook 'notmuch-show-mode-hook 'turn-off-auto-fill)
  :config (advice-add 'text-scale-adjust :after
                      #'visual-fill-column-adjust))
#+END_SRC
On a similar note, I don't want filling the paragraph to do anything, unless I
really do.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun og/maybe-fill-paragraph ()
  (interactive)
  (when current-prefix-arg
      (fill-paragraph)))

(bind-key "M-q" #'og/maybe-fill-paragraph notmuch-message-mode-map)
#+END_SRC
I don't want to manually do this.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(advice-add #'notmuch-show-reply-sender :after (lambda! () (open-line 1)))
#+END_SRC
Accessing mail. When we first open up =notmuch=, I want to start a system script
that checks for new mail periodically.
#+BEGIN_SRC emacs-lisp
(defun og/open-mail ()
  (interactive)
  (notmuch)
  (notmuch-refresh-this-buffer))

(bind-key "C-c m" #'og/open-mail)
#+END_SRC
*** Hard Delete Mail
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun og/notmuch-delete-mail ()
  (interactive)
  (notmuch-search-tag (list "+deleted"))
  (call-process-shell-command
   "notmuch search --output=files --format=text0 tag:deleted | xargs -0 rm && notmuch new"
   nil nil nil)
  (notmuch-search-refresh-view))

(bind-key "D" #'og/notmuch-delete-mail notmuch-search-mode-map)
#+END_SRC
*** See Last Unread in Thread
Notmuch doesn't take you to the latest unread message in a thread. Usually, you
can work around this by going to the end of the buffer, but this doesn't work if
the thread is non-linear and the message of interest is somewhere in the middle.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun og/next-unread ()
  (interactive)
  (let ((init (point)))
    (catch 'break
      (while t
        (when (member "unread" (notmuch-show-get-tags))
          (let ((props (notmuch-show-get-message-properties)))
            (notmuch-show-message-visible props t)
            (notmuch-show-mark-read)
            (throw 'break t)))
        (when (not (notmuch-show-goto-message-next))
          (message "No more unread messages.")
          (goto-char init)
          (throw 'break t))))))

(bind-key "U" #'og/next-unread notmuch-show-mode-map)
#+END_SRC
*** Send HTML Mail
This code from [[http://kitchingroup.cheme.cmu.edu/blog/category/orgmode/4/][John Kitchin]] lets you write mail in Org Mode and send it
formatted as HTML. This is incredibly powerful, because you can include syntax
highlighted code, LaTeX math images, and even the image output of Babel blocks,
all composed in plain text with Org Mode. Unfortunately, when I first set up
this process, I received an error when trying to send HTML mail with LaTeX math
in it (the desired =.png= was not produced and I had to adjust =imagemagick= as
apart of =org-preview-latex-process-alist=). Investigating the =.log= files showed
that the issue was not with =pdflatex= (and indeed a proper PDF was
produced). In fact, the issue was with ImageMagick, which did not have the
proper permissions to do its job on PDF files. Here's the fix:

Find =/etc/ImageMagick-7/policy.xml=. Change
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="none" pattern="PDF" />
#+END_SRC
to
#+BEGIN_SRC html :tangle no
<policy domain="coder" rights="read|write" pattern="PDF" />
#+END_SRC
Looking at the =rights= field makes it clear that the permissions were off.

Now for the Emacs setup. This library converts Org into HTML.
#+BEGIN_SRC emacs-lisp
(autoload 'org-mime-htmlize "org-mime")
#+END_SRC
Then we give ourselves a way to activate Org Mode mail, and also to send HTML
mail by default.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref notmuch-settings
(defun og/compose-html-org ()
  (interactive)
  (setq *compose-html-org* t)
  (org-mode)
  (quick-math-mode)
  (auto-fill-mode -1))

(bind-key "M-m" #'og/compose-html-org notmuch-message-mode-map)
;; (bind-key "C-c C-c" (lambda! () (progn (og/compose-html-org) (og/org-htmlize-and-send))) notmuch-message-mode-map)
#+END_SRC
Let's define a function to send the mail.
#+BEGIN_SRC emacs-lisp
(defun og/org-htmlize-and-send ()
  "When composing an Org HTML message, htmlize and send it."
  (interactive)
  (when (and (not (org-in-src-block-p))
             (bound-and-true-p *compose-html-org*))
    (setq *compose-html-org* nil)
    (notmuch-message-mode)
    (org-mime-htmlize)
    (notmuch-mua-send-and-exit)))

(add-hook 'org-ctrl-c-ctrl-c-hook 'og/org-htmlize-and-send t)
#+END_SRC
If we're sending HTML, we might as well make it pretty. Let's nicely offset
block quotes.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mime-html-hook
          (lambda ()
            (org-mime-change-element-style
             "blockquote" "border-left: 2px solid gray; padding-left: 4px;")))
#+END_SRC
We definitely don't want to export the table of contents or section numbers.
It's an email, not an essay.
#+BEGIN_SRC emacs-lisp
(setq org-mime-export-options '(:section-numbers nil
                                :with-author nil
                                :with-toc nil))
#+END_SRC
Mod by John Kitchin.
#+BEGIN_SRC emacs-lisp
(defun org-mime-compose (body fmt file &optional to subject headers)
  (require 'message)
  (let ((bhook
         (lambda (body fmt)
           (let ((hook (intern (concat "org-mime-pre-"
                                       (symbol-name fmt)
                                       "-hook"))))
             (if (> (eval `(length ,hook)) 0)
                 (with-temp-buffer
                   (insert body)
                   (goto-char (point-min))
                   (eval `(run-hooks ',hook))
                   (buffer-string))
               body))))
        (fmt (if (symbolp fmt) fmt (intern fmt)))
        (files (org-element-map (org-element-parse-buffer) 'link
                 (lambda (link)
                   (when (string= (org-element-property :type link) "file")
                     (file-truename (org-element-property :path link)))))))
    (compose-mail to subject headers nil)
    (message-goto-body)
    (cond
     ((eq fmt 'org)
      (require 'ox-org)
      (insert (org-export-string-as
               (org-babel-trim (funcall bhook body 'org)) 'org t)))
     ((eq fmt 'ascii)
      (require 'ox-ascii)
      (insert (org-export-string-as
               (concat "#+Title:\n" (funcall bhook body 'ascii)) 'ascii t)))
     ((or (eq fmt 'html) (eq fmt 'html-ascii))
      (require 'ox-ascii)
      (require 'ox-org)
      (let* ((org-link-file-path-type 'absolute)
             ;; we probably don't want to export a huge style file
             (org-export-htmlize-output-type 'inline-css)
             (org-html-with-latex 'dvipng)
             (html-and-images
              (org-mime-replace-images
               (org-export-string-as (funcall bhook body 'html) 'html t)))
             (images (cdr html-and-images))
             (html (org-mime-apply-html-hook (car html-and-images))))
        (insert (org-mime-multipart
                 (org-export-string-as
                  (org-babel-trim
                   (funcall bhook body (if (eq fmt 'html) 'org 'ascii)))
                  (if (eq fmt 'html) 'org 'ascii) t)
                 html)
                (mapconcat 'identity images "\n")))))
    (mapc #'mml-attach-file files)))
#+END_SRC
*** Don't Forget Attachments
From [[https://gitlab.com/ambrevar/dotfiles/blob/master/.emacs.d/lisp/patch-notmuch.el][ambrevar's dotfiles]].
#+BEGIN_SRC emacs-lisp
(defcustom notmuch-message-attach-regex
  "\\b\\(attache\?ment\\|attached\\|attach\\|pi[èe]ce\s+jointe?\\)\\b"
  "Pattern of text announcing there should be an attachment.

This is used by `notmuch-message-check-attach' to check email
bodies for words that might indicate the email should have an
attachement. If the pattern matches and there is no attachment (a
`<#part ...>' magic block), notmuch will show a confirmation
prompt before sending the email.

The default regular expression is deliberately liberal: we prefer
false positive than forgotten attachments. This should be
customized for non-english languages and notmuch welcomes
additions to the pattern for your native language, unless it
conflicts with common words in other languages."
  :type '(regexp)
  :group 'notmuch-send)

(defun notmuch-message-check-attach ()
  """Check for missing attachments.

This is normally added to `message-send-hook' and is configured
through `notmuch-message-attach-regex'."""
  (save-excursion ;; XXX: this fails somehow: point is at the end of the buffer on error
    (goto-char (point-min))
    (if (re-search-forward notmuch-message-attach-regex nil t)
        (progn
          (goto-char (point-min))
          (unless (re-search-forward "<#part [^>]*filename=[^>]*>" nil t)
            (or (y-or-n-p "Email seems to refer to attachment, but nothing attached, send anyways?")
                (error "No attachment found, aborting")))))))

(add-hook 'message-send-hook #'notmuch-message-check-attach)
#+END_SRC
*** Unsubscribe
#+BEGIN_SRC emacs-lisp
(defun og/notmuch-show-unsubscribe ()
   "When in a notmuch show mail, try to find an unsubscribe link and
click it. This will be the link nearest the end of the message which
either contains or follows the word unsubscribe."
(interactive)
(notmuch-show-move-to-message-bottom)
(when (search-backward "unsubscribe" (notmuch-show-message-top))
  (if (ffap-url-at-point)
      (goto-char (car ffap-string-at-point-region)))
  (ffap-next-url)))
#+END_SRC
** Music
I got the setup information from [[https://www.reddit.com/r/emacs/comments/981khz/emacs_music_player_with_emms/][Reddit]] and [[https://www.youtube.com/watch?v=xTVN8UDScqk][this video]].
#+BEGIN_SRC emacs-lisp
(defvar og/emms-started nil)

(defun og/emms-setup ()
  (add-to-list 'load-path (expand-file-name "emms/lisp/" gmacs-custom-dir))
  (require 'emms-setup)
  (require 'emms-player-mpd)
  (emms-all)
  (require 'emms-mode-line)
  (emms-mode-line 1)
  (require 'emms-playing-time)
  (emms-playing-time 1)
  (unless og/emms-started
    (setq og/emms-started t)
    (condition-case nil
        (emms-player-mpd-connect)
      (error nil))))
#+END_SRC
We'll run our customizations once =emms= starts.
#+BEGIN_SRC emacs-lisp :noweb yes
(after! emms
    <<emms>>)
#+END_SRC
Now for the settings. I use =mpd= a minimal daemon for playing music.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref emms
(setq emms-seek-seconds 5
      emms-player-list '(emms-player-mpd)
      emms-info-list '(emms-info-mpd)
      emms-player-mpd-server-name "localhost"
      emms-player-mpd-server-port "6601"
      emms-source-file-default-directory "~/music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t)
#+END_SRC
We use non-default settings for the socket. In order to use the built-in
functionality for =mpc=, we need to let Emacs know about this.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref emms
(setq mpc-host "localhost:6601")
#+END_SRC
When the music I have isn't tagged right or needs some editing, I use the
command line tool =id3v2= for quick or repetitive jobs. When appropriate, I prefer
the GUI application =easytag=.
*** Starting MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/start-music-daemon ()
  "Start MPD, connects to it and syncs the metadata cache."
  (interactive)
  (shell-command "mpd")
  (emms-player-mpd-update-all-reset-cache)
  (emms-player-mpd-connect)
  (emms-cache-set-from-mpd-all)
  (message "MPD Started!"))
#+END_SRC
*** Killing MPD from Emacs
#+BEGIN_SRC emacs-lisp
(defun mpd/kill-music-daemon ()
  "Stops playback and kill the music daemon."
  (interactive)
  (emms-stop)
  (call-process "killall" nil nil nil "mpd")
  (message "MPD Killed!"))
#+END_SRC
*** Bindings
I use a prefix map to compactify this set of keybindings.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-emms (:color pink :pre (og/emms-setup))
  "
  ^
  ^EMMS^            ^Track^             ^MPD (daemon)^
  ^────────^──────────^──────^────────────^───────^─────
  _q_uit            _p_ause             _c_reate
  _e_mms            _P_revious          _k_ill
  _b_rowse          _N_ext              _r_eload
  ^^                _B_ack (10s)       ^^
  ^^                _F_orward (10s)     ^^
  ^^                ^^                  ^^
  "
  ("q" nil)
  ("e" emms :color blue)
  ("b" emms-smart-browse :color blue)
  ("P" emms-previous)
  ("N" emms-next)
  ("p" emms-pause)
  ("B" emms-seek-backward)
  ("F" emms-seek-forward)
  ("k" mpd/kill-music-daemon)
  ("c" mpd/start-music-daemon)
  ("r" emms-player-mpd-update-all-reset-cache :color blue))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(bind-key "M-m" #'hydra-emms/body)
#+END_SRC
* Snippets
I use =SPC= instead of the default =TAB= to expand snippets. I find this more
convenient, because it makes typing a snippet more like typing a word. This
works fine apart from one hiccup. We need to bind =TAB= to =org-cycle= (even though
that is the default in Org Mode). Otherwise, binding =TAB= to =nil= in
=yas-minor-mode= overrides the default behaviour.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode yas-global-mode)
  :config
  (bind-key "<tab>" nil yas-minor-mode-map)
  (bind-key "TAB" nil yas-minor-mode-map)
  (define-key yas-minor-mode-map (kbd "SPC")
              (or (bound-and-true-p yas-maybe-expand) #'yas-expand))
  :custom
  (yas-triggers-in-field t) ; expand snippets within snippets
  (yas-wrap-around-region t)
  (yas-snippet-dirs '("~/.emacs.d/snippets")))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (yas-global-mode 1)
  (diminish 'yas-minor-mode " ✂"))
#+END_SRC
** QuickMath
I use a hydra for snippets that just insert/replace text in math mode and thus
don't require the use of =yasnippets=.
*** Math Symbols
**** Main Math Snippets
Snippets go in [[file:math-snippets.el]].
#+BEGIN_SRC emacs-lisp
(defcustom og/math-snippets nil
  "Contains lists (KEY EXPANSION SNIPPET). When KEY is typed, it
  will be replaced with EXPANSION. If SNIPPET is non-nil,
  EXPANSION is taken to be a loaded yasnippet. Otherwise, it is
  considered the replacement string."
  :type 'alist
  :group 'quick-math)

(defvar og/math-global-snippets nil)
(defvar-local og/math-local-snippets nil)
(defvar og/math-snippet-loc (expand-file-name "math-snippets.el" user-emacs-directory))
#+END_SRC
**** Hydras
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref hydra
(defhydra hydra-semicolon-a (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-b/body "Level 2")
  ("SPC" (insert "; ") ";")
  ("a" (insert "\\alpha{}") "α")
  ("A" (insert "\\forall ") "∀")
  ("b" (insert "\\beta{}") "β")
  ("C" (yas-expand-snippet (yas-lookup-snippet "mathcal")) "ℂ")
  ("c" (insert "\\xi{}") "ξ")
  ("C" (insert "\\Xi{}") "Ξ")
  ("d" (insert "\\delta{}") "δ")
  ("D" (insert "\\Delta{}") "Δ")
  ("e" (insert "\\epsilon{}") "ε")
  ("E" (insert "\\exists ") "∃")
  ("f" (insert "\\varphi{}") "φ")
  ("F" (insert "\\Phi{}") "Φ")
  ("g" (insert "\\gamma{}") "γ")
  ("G" (insert "\\Gamma{}") "Γ")
  ("h" (insert "\\eta{}") "η")
  ("i" (insert "\\iota{}") "ι")
  ("k" (insert "\\kappa{}") "κ")
  ("l" (insert "\\lambda{}") "λ")
  ("L" (insert "\\Lambda{}") "Λ")
  ("m" (insert "\\mu{}") "µ")
  ("n" (insert "\\nu{}") "ν")
  ("o" (insert "\\omega{}") "ω")
  ("O" (insert "\\Omega{}") "Ω")
  ("p" (insert "\\pi{}") "π")
  ("P" (insert "\\Pi{}") "Π")
  ("q" (insert "\\theta{}") "θ")
  ("Q" (insert "\\Theta{}") "Θ")
  ("r" (insert "\\rho{}") "ρ")
  ("R" (insert "\\mathbb{R}") "ℝ")
  ("s" (insert "\\sigma{}") "σ")
  ("S" (insert "\\Sigma{}") "Σ")
  ("t" (insert "\\tau{}") "τ")
  ("u" (insert "\\cup ") "∪")
  ("U" (yas-expand-snippet "\\bigcup_{$1}^{$2}$0"))
  ("v" (insert "\\vee{}") "V")
  ("V" (insert "\\wedge{}") "V")
  ("w" (insert "\\omega{}") "ω")
  ("W" (insert "\\Omega{}") "Ω")
  ("x" (insert "\\chi{}") "χ")
  ("y" (insert "\\psi{}") "ψ")
  ("Y" (insert "\\Psi{}") "Ψ")
  ("z" (insert "\\zeta{}") "ζ")
  ("Z" (insert "\\mathbb{Z}") "ℤ")
  ("0" (insert "\\emptyset") "∅")
  ("8" (insert "\\infinity") "∞")
  ("!" (insert "\\neg") "¬")
  ("*" (insert "\\star") "⋆")
  ("/" (og/math-frac))
  ("\\" (insert "\\setminus ") "∖")
  ("'" (insert "\\prime ") "′")
  ("," (insert ",\\ldots,") ".")
  ("." (insert "\\cdot ") "·"))

(defhydra hydra-semicolon-b (:color blue :idle 1.0 :columns 8)
  (";" hydra-semicolon-a/body "base")
  (" " (insert "; " "semicolon"))
  ("A" (insert "\\aleph ") "")
  ("e" (insert "\\varepsilon ") "ε")
  ("f" (insert "\\phi{}") "φ")
  ("F" (insert "\\mathbb{F}") "𝔽")
  ("l" (insert "\\ell{}") "ℓ")
  ("n" (insert "\\cap ") "∩")
  ("N" (yas-expand-snippet "\\bigcap_{$1}^{$2}$0"))
  ("o" (insert "\\circ{}") "∘")
  ("q" (insert "\\vartheta{}") "ϑ")
  ("r" (insert "\\wp{}") "ρ")
  ("s" (insert ";") ";")
  ("u" (insert "\\sqcup ") "∩")
  ("U" (insert "\\cap ") "∩")
  ("N" (insert "\\nabla") "∇")
  ("w" (insert "\\varpi{}") "ϖ")
  ("x" (insert " \\times ") "×")
  ("." (insert "\\cdots{}") "···"))
#+END_SRC
Then we bind this to semicolon.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key og/math-mode-map ";" #'hydra-semicolon-a/body (og/in-math-p))
#+END_SRC
*** Helper Functions
**** QuickMath Minor Mode
#+BEGIN_SRC emacs-lisp :noweb no-export
(after! org
  (defvar og/math-mode-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map org-mode-map)
      map))
  <<math-mode>>
  (define-minor-mode quick-math-mode
    "Minor mode for math"
    :init-value nil
    :keymap og/math-mode-map
    (when (file-exists-p abbrev-file-name)
          (abbrev-table-put org-mode-abbrev-table
                  :parents (list quick-math-mode-abbrev-table)))
    (when quick-math-mode
      (og/math-setup)
      (og/eq-preview-mode)
      (pretty-math-mode)
      (setq org-highlight-latex-and-related '(latex)))))
#+END_SRC
We need shift-tabbing in snippets to override =org-shift-tab=, but only in math
mode.
#+BEGIN_SRC emacs-lisp
(define-conditional-key og/math-mode-map (kbd "<S-iso-lefttab>") (lambda! (yas-next-field -1)) (og/in-math-p))
#+END_SRC
**** Simpler =texmathp=
The default =texmathp= function assumes that you are writing valid LaTeX code.
This is all well and good when you are actually writing LaTeX, where things like
the dollar sign have only one meaning, but I write documents almost entirely in
Org Mode (I export them to LaTeX). Here the function easily gets confused. So I
make my own for checking if you are in math mode, which leverages Org Mode's
font-locking to narrow down the area we need to check. We first make a list of
math environments that our function will look for.
#+BEGIN_SRC emacs-lisp
(defvar og/math-environments '("equation" "align" "gather")
  "The environments `og/in-math-p' assumes as valid math environments.")
#+END_SRC
The only way we're in math mode is if we're in a LaTeX fragment. However, the
latter sometimes returns false positives when it comes to math mode. That is, we
can be in a LaTeX fragment (like a =figure= environment) without being in math
mode.

When Org says we're in inline LaTeX, we're definitely in math mode. If we're in
an environment, we check from the beginning of the environment to the point. If
there are more opening delimiters than closing ones (more of =\begin{ENV}= then
=\end{ENV}=, where =ENV= is an element of =og/math-environments=), then the point must
be in math. The one subtlety is that we also look at the starred versions of
=ENV=.
#+BEGIN_SRC emacs-lisp
(defun og/in-math-p-regexp (begin-delim)
  (concat begin-delim (regexp-opt og/math-environments) "[\\*]?}"))

(defun og/in-math-p (&optional loc)
  (if (boundp 'latex-mode)
      (when (eq major-mode 'latex-mode)
        (texmathp))
    (progn
      (unless loc (setq loc (point)))
      (let* ((fr (org-element-context))
             (fr-type (car fr))
             (begin (org-element-property :begin fr)))
        (save-excursion
          (if (condition-case nil
                  (progn
                    (re-search-backward "\\text" begin)
                    (forward-word)
                    (forward-sexp)
                    (> (point) loc))
                (error nil))
              nil
            (cond ((eq fr-type 'latex-fragment)
                   (and
                    (> loc begin)
                    (<= loc (1- (- (org-element-property :end fr)
                                   (org-element-property :post-blank fr))))))
                  ((eq fr-type 'latex-environment)
                   (let ((env-open (how-many (og/in-math-p-regexp "\\\\begin{") begin loc))
                         (env-close (how-many (og/in-math-p-regexp "\\\\end{") begin loc)))
                     (> (- env-open env-close) 0))))))))))
#+END_SRC
**** Enter Math Mode
Enter a math fragment if inside one, exit otherwise.
#+BEGIN_SRC emacs-lisp
(defun og/create-or-exit-math-fragment ()
  (interactive)
  (if (og/in-math-p)
      (og/reformat-fragment)
    (when (yas-active-snippets)
      (yas-exit-all-snippets))
    (insert "\\(")
    (save-excursion (insert "\\)"))))
#+END_SRC
**** Last n Characters Before Point
Return the last n characters before the point, or =loc= if provided. Provide fewer
characters if there are not enough. Return nil if =loc= is too large.
#+BEGIN_SRC emacs-lisp
(defun og/last-n-chars (n &optional loc)
  (when (use-region-p) (setq loc (region-end)))
  (unless loc (setq loc (point)))
  (let ((start (- loc n)))
    (when (<= start (point-max))
      (buffer-substring-no-properties (max (point-min) (- loc n)) loc))))
#+END_SRC
**** Last LaTeX Letter
Postfix commands often act on the last letter. For example, I want =fhat= to
expand into =\hat{f}=. However, we cannot just act on the last letter, because
=\betahat= should expand into =\hat{beta}=, not the invalid =\bet\hat{a}=.
#+BEGIN_SRC emacs-lisp
(defun og/last-letter ()
  (defun og/--last-letter-helper ()
    (when (string-match "[a-zA-Z]" (og/last-n-chars 1))
      (let ((match
             (if (looking-back (regexp-opt
                                (cl-loop for letter in (append og/math-greek-lower
                                                        og/math-greek-upper
                                                        '(("ell")))
                                  collect (concat "\\" (car letter))))
                               (- (point) 8) t)
                 (buffer-substring-no-properties (match-beginning 0)
                                                 (match-end 0))
               (char-to-string (char-before)))))
        (backward-char (length match))
        (cond ((string= (og/last-n-chars 5) "\\vec ")
               (setq match (format "\\vec %s" match)))
              ((eq (char-before) ?\\)
               (setq match (format "\\%s" match))))
        match)))
  (save-excursion
    (if (string-match "}" (og/last-n-chars 1))
        (progn (backward-char 2)
               (concat (og/--last-letter-helper) "{}"))
      (og/--last-letter-helper))))
#+END_SRC
I use this for postfix snippets, as explained.
#+BEGIN_SRC emacs-lisp
(defun og/math-postfix (snippet)
  (let ((len (length (og/last-letter))))
    (if (> len 0)
        (progn
          (backward-char len)
          (insert (format "\\%s{" snippet))
          (forward-char len)
          (insert "}"))
      (yas-expand-snippet (format "\\%s{$1}" snippet)))))
#+END_SRC
**** Test if LaTeX Needs to Be Wrapped in Brackets
#+BEGIN_SRC emacs-lisp
(defun og/math-expression-p (math)
  (when math
    (or (eq (length math) 1)
        ;; Match one single latex macro such as \command
        ;; Only validate if this is the entire string
        (string-match-p (concat "\\`\\\\" "[a-zA-Z]+\\({}\\)?\\'") math))))
#+END_SRC
**** Increment Snippet Fields
#+BEGIN_SRC emacs-lisp
(defun og/increment-snippet-fields (string &optional n)
  (unless n (setq n 1))
  (replace-regexp-in-string "[1-9]+" (lambda (x) (format "%d" (+ n (string-to-number x)))) string))
#+END_SRC
**** Generate Snippets
:PROPERTIES:
:ORDERED:  t
:END:
I wrote this to reduce the amount of redundant code needed to set up the
snippets. We create a list of the last characters of all the math
snippets and bind each of these to a snippet expansion command.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(defvar og/longest-snippet)

(defvar og/math-snippet-by-suffix)

(defun og/math-snippet--bind-keys (keys)
  (dolist (key keys)
    (eval `(define-conditional-key og/math-mode-map
               ,key (lambda! () (og/math-snippet-expand ,key))
             (og/in-math-p)))))

(defun og/math-snippet--create-suffix-tree (keys)
  (setq og/math-snippet-by-suffix nil)
  (dolist (key keys)
    (push (cons key '()) og/math-snippet-by-suffix))
  (dolist (snippet og/math-snippets)
    (let* ((key (car snippet))
           (last (s-right 1 key))
           (rest (s-left -1 key)))
      (push rest (alist-get last og/math-snippet-by-suffix nil nil 'equal)))))

(defvar og/math-unique-suffixes nil)

(defun og/math-setup ()
  (load og/math-snippet-loc)
  (setq og/math-snippets (append og/math-local-snippets og/math-global-snippets))
  (setq og/longest-snippet
        (cons (apply #'max
                     (cl-loop for snippet in og/math-snippets
                              collect (length (car snippet))))
              (apply #'max
                     (cl-loop for snippet in og/math-snippets
                              collect (length (cadr snippet))))))
  (cl-loop for i from 0 to 9
           do (push (number-to-string i) og/math-unique-suffixes))
  (setq og/math-unique-suffixes
        (delete-dups (append
                      (cl-loop for snippet in og/math-snippets
                               collect (substring (reverse (car snippet)) 0 1))
                      og/math-unique-suffixes)))
  (og/math-snippet--bind-keys og/math-unique-suffixes)
  (og/math-snippet--create-suffix-tree og/math-unique-suffixes))
#+END_SRC
We make a function to get the possible completion candidates from the buffer.
#+BEGIN_SRC emacs-lisp
(defun og/buff-cand (n)
  (cl-loop for i from 0 to n
        collect (og/last-n-chars i)))
#+END_SRC
Then, we set up the creation of an actual snippet (note that its length is
capped at a certain number of characters, defined by =og/longest-snippet=).
#+BEGIN_SRC emacs-lisp
(defun og/math-snippet-expand-p (key)
  (-if-let* ((buff-cand (og/buff-cand (car og/longest-snippet)))
             (completions (seq-intersection
                           buff-cand
                           (alist-get key og/math-snippet-by-suffix nil nil 'equal)))
             (snippet-match (car (seq-sort-by #'length #'> completions)))
             (snippet (assoc (concat snippet-match key) og/math-snippets)))
      snippet))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun og/math-snippet-expand (key)
  (-if-let* ((snippet (og/math-snippet-expand-p key))
             (expand (cadr snippet)))
      (progn
        ;; this has to be negative, we're deleting back
        (delete-char (- 1 (length (car snippet))))
        ;; this is so we don't have two backslashes after something like \sim
        (when (= (char-before) ?\\) (delete-char -1))
        ;; is this a snippet expansion or just a text insertion?
        (yas-expand-snippet (if (cddr snippet) (yas-lookup-snippet expand) expand)))
    (if (string-match "[0-9]" key)
        (og/math-number-subscript key)
      (insert key))))
#+END_SRC
**** Add and View Snippet
Now we give the user a way to easily add snippets.
#+BEGIN_SRC emacs-lisp
(defun og/new-math-snippet ()
  "Creates a new math snippet. Adds the cons (KEY . NAME) to
`og/math-snippets'. If no snippet with the name NAME exists in
the yasnippet directory for latex-mode, then the such a file is
created. The user can then write the code into which te snippet
should expand."
  (interactive)
  (let* ((key (read-string "Snippet key: "))
         (text (read-string "Snippet text (leave blank if using yasnippet): "))
         (name (when (s-blank-str? text)
                 (read-string "Snippet name: ")))
         (file-cand (expand-file-name
                     (format "%s/latex-mode/%s" (car (yas-snippet-dirs)) name)))
         (snippet (if (s-blank-str? text)
                      (list key name t)
                    (list key text)))
         (snippet-keys (cl-loop for snippet in og/math-global-snippets
                                collect (car snippet)))
         (snippet-list (cl-loop for snippet in og/math-global-snippets
                                collect (cons (car snippet) snippet))))
    (unless (s-blank-str? name)
      (find-file file-cand)
      (unless (file-exists-p file-cand)
        (yas-expand-snippet (yas-lookup-snippet "new-math-snippet"))))
    (when (and (member (car snippet) snippet-keys)
               (y-or-n-p (format "Snippet %s is already defined. Overwrite?" key)))
      (setq og/math-global-snippets (delete (cdr (assoc key snippet-list)) og/math-global-snippets)))
    (push snippet og/math-global-snippets)
    (unless current-prefix-arg
      (setq og/math-global-snippets og/math-global-snippets))
    (dump-vars-to-file '(og/math-global-snippets) og/math-snippet-loc t)
    (og/math-setup)))
#+END_SRC
A very rudimentary command to see all current snippet keys and expansions.
#+BEGIN_SRC emacs-lisp
(defun og/view-snippets ()
  (interactive)
  (setq og/math-snippets
        (seq-sort-by #'car #'string< og/math-snippets))
  (with-output-to-temp-buffer "*QuickMath Expansions*"
    (let ((key-len (+ 4 (car og/longest-snippet)))
          (snip-len (cdr og/longest-snippet)))
      (princ (format "Key%s  Snippet%s\n%s%s\n"
                     (make-string (- key-len 4) ? )
                     (make-string (- snip-len 8) ? )
                     (make-string key-len ?-)
                     (make-string (1+ snip-len) ?-)))
      (dolist (snippet og/math-snippets)
        (princ (format "%s %s\n"
                       (concat
                        (car snippet)
                        (make-string (- key-len (length (car snippet))) ? ))
                       (nth 1 snippet)))))))
#+END_SRC
**** Tab Jump to Next LaTeX Position
Modified from the =cdlatex-tab= function in =cdlatex.el=.
#+BEGIN_SRC emacs-lisp
(defun math-tab ()
  (interactive)
  (if (yas-active-snippets t)
      (yas-next-field)
      (catch 'stop
        (cond
         ((looking-at "}\\|\\]\\|)")
          (forward-char 1)
          (if (or (looking-at "\\\\") (looking-at "[^_\\^({\\[]"))
              (throw 'stop t)))
         ((= (following-char) ?$)
          (while (= (following-char) ?$) (forward-char 1))
          (throw 'stop t))
         ((= (following-char) ?\ )
          (forward-char 1)
          (re-search-forward "[^ ]")
          (if (/= (preceding-char) ?\n) (forward-char -1)))
         (t
          (forward-char 1)))
        (while (re-search-forward "[ )}\n]\\|\\]" (point-max) t)
          (forward-char -1)
          (cond
           ((= (following-char) ?\ )
            (if (not (bolp)) (forward-char 1)) (throw 'stop t))
           ((= (following-char) ?\n)
            (if (and (bolp) (not (eobp)))
                (throw 'stop t)
              (if (equal "\\\\" (buffer-substring-no-properties
                                 (- (point) 2) (point)))
                  (forward-char 1)
                (throw 'stop t))))
           (t
            (if (or (= (char-syntax (preceding-char)) ?\()
                    (= (char-syntax (preceding-char)) ?\))
                    (= (preceding-char) ?-))
                (throw 'stop t)
              (forward-char 1)
              (if (looking-at "[^_\\^({\\[]")
                  (throw 'stop t)))))))
    (unless (og/in-math-p)
      (forward-char -1)
      (og/reformat-fragment))))
;; right bracket
#+END_SRC
Bind to tab.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key og/math-mode-map (kbd "<tab>") #'math-tab (og/in-math-p))
#+END_SRC
**** Subscripts/Indices
This function eases the entry of subscripts such as =x_0= or =a_{12}=. When a
digit is pressed, if the last character is a letter, then a subscript is
created. If this subscript is extended to a number with more than 1 digit,
brackets are added to ensure proper LaTeX rendering. I also rarely enter a
numbered subscript of more than two digits, so I also exit the brackets after
creating them.
#+BEGIN_SRC emacs-lisp
(defun og/math-number-subscript (n)
  (insert n)
  (save-excursion
    (cond ((save-excursion
             (backward-char)
             (> (length (replace-regexp-in-string "[{}]" "" (if (og/last-letter) (og/last-letter) ""))) 1))
             (backward-char)
             (insert "_"))
          ((string-match "[a-zA-Z][0-9]" (og/last-n-chars 2))
             (backward-char)
             (insert "_"))
          ((string-match "\_[0-9][0-9]" (og/last-n-chars 3))
           (save-excursion
             (backward-char 2)
             (insert "\{"))
           (insert  "\}")))))
#+END_SRC
Add subscript bindings to each of the ten digits.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
;; (cl-loop for i from 0 to 9
;;          collect (eval (macroexpand `(define-conditional-key og/math-mode-map
;;                                          (number-to-string ,i)
;;                                          (lambda! () (og/math-number-subscript (number-to-string ,i)))
;;                                        (og/in-math-p)))))
#+END_SRC
**** Fraction
Typing =/= after an appropriate block (a number or a balanced set of parentheses)
creates a fraction with this block in the numerator and the point in the
denominator. The outside parentheses will be removed; for example, =(\sin x)/=
results in =\frac{\sin x}{|}=.

First, this is a set of extra strings that we accept as a prefix to a match.
There is also a list of strings which do not count as words for the purposes of
=og/math-frac--backward-word=.
#+BEGIN_SRC emacs-lisp
(defvar og/math-frac-extras
  '("\\vec"))

(defvar og/math-frac-non-words
  '("sum"))
#+END_SRC
We write a function to go backward from the point until no more characters match.
#+BEGIN_SRC emacs-lisp
;; Go backward by a latex sub/superscript
(defun og/math-frac--backward-script ()
  (cond
   ((string-match-p "[_^]." (og/last-n-chars 2))
    (backward-char 2))
   ;; 125 is right curly brace
   ((and (eq (char-before) 125)
         (string-match-p "[_^]" (save-excursion
                                  (backward-sexp)
                                  (char-to-string (char-before)))))
    (backward-sexp)
    (backward-char))))

(defun og/math-frac--backward-word ()
  (let ((pt (point)))
    (save-excursion
      (when (string-match-p "{}" (og/last-n-chars 2))
        (backward-char 2))
      (when (and (string-match-p "\\w" (char-to-string (char-before)))
                 (not (member (thing-at-point 'word 'no-properties) og/math-frac-non-words)))
        (backward-word)
        (when (equal (char-before) (string-to-char "\\"))
          (backward-char))
        (setq pt (point))))
    (goto-char pt)))

(defun og/math-frac--backward-match ()
  ;; do this until we encounter a space character, or until we get into an
  ;; infinite loop, and make sure the sub/superscripts connect to a valid word
  (let ((pt (point-min)))
    (while (not (or (eq (point) (point-min))
                    (eq pt (point))
                    (string-match-p "[[:space:]]" (char-to-string (char-before)))))
      (setq pt (point))
      (og/math-frac--backward-script)
      (og/math-frac--backward-script)
      ;; break loop and undo this step if this turns out not to be a valid word
      (let ((ptcand (save-excursion (og/math-frac--backward-word)
                                    (point))))
        (if (eq ptcand (point))
            (goto-char pt)
          (goto-char ptcand))))
    (condition-case nil
        (re-search-backward (concat (regexp-opt og/math-frac-extras) "\\( \\|{}\\)"))
      (error nil))))
#+END_SRC
This gets plugged into a function that gets the maximal matching suffix of a string.
#+BEGIN_SRC emacs-lisp
(defun og/math-frac--start-of-match-string (str)
  "Return maximal matching suffix for a fraction match.

Match a LaTeX word with 0 to 2 sub/superscripts that is not
preceded by ^ or _ (because this means something like matching
the 1 in x_1). Allow possibly being preceded by a math extra in
`og/math-frac--start-of-match-string' The match must end at
point."
  (with-temp-buffer
    (insert str)
    (goto-char (point-max))
    (og/math-frac--backward-match)
    (buffer-substring-no-properties (point) (point-max))))
#+END_SRC
Now we use this as the matching function in a function that returns the spot in
the buffer where the maximal suffix begins.
#+BEGIN_SRC emacs-lisp
(defvar og/math-frac-start-of-match-func 'og/math-frac--start-of-match-string)

(defun og/math-frac--get-max-start ()
  (let* ((fr (org-element-context))
         (fr-type (car fr))
         (fr-begin (org-element-property :begin fr)))
    ;; Casework for farthest to look back
    (max (line-beginning-position)
         (if (eq fr-type 'latex-fragment)
             ;; add 2 to account for \( \)
             (+ 2 fr-begin)
           0)
         (condition-case nil
             (marker-position
              (yas--field-start
               (yas--snippet-active-field (car (yas-active-snippets)))))
           (error 0)))))

(defun og/math-frac--start-of-match ()
  "Return start of maximal match ending at point.

Look no further back than bol for environment and start of
fragment for inline math, and never any further than the start of
the most recently activated snippet"
  (let* ((max-start (og/math-frac--get-max-start))
         (max-match (buffer-substring-no-properties max-start (point)))
         (match (funcall og/math-frac-start-of-match-func max-match)))
    (- (point) (length match))))
#+END_SRC
Finally, we write the main function.
#+BEGIN_SRC emacs-lisp
(defun og/math-frac--process-match (match)
  (replace-regexp-in-string "\\`(\\(.*\\))\\'" "\\1" match))

(defun og/math-frac--insert-match (match env)
  (yas-expand-snippet (yas-lookup-snippet env))
  (insert (og/math-frac--process-match match))
  (yas-next-field))

(defun og/math-frac--region (beg end env)
  "Replace text in region with fraction"
  ;; default to frac environment
  (unless env (setq env "frac"))
  (let ((match (buffer-substring-no-properties beg end)))
    (delete-region beg end)
    (og/math-frac--insert-match match env)))

(defun og/math-frac (&optional env)
  (interactive)
  ;; use fraction if called with C-u and quotient if called with C-u C-u
  (unless env
    (setq env (cond
               ((equal current-prefix-arg '(4)) "frac")
               ((equal current-prefix-arg '(16)) "quotient"))))
  (let ((ch (char-to-string (char-before)))
        (end (point)))
    (cond
     ;; active region
     ((use-region-p)
      (og/math-frac--region (region-beginning) (region-end) env))
     ;; match is surrounded in brackets
     ((string-match-p "[\])]" ch)
      (let ((beg (progn
                   (backward-sexp)
                   (point))))
        ;; For example, R[X] should use quotient by default
        (when (equal ch "]")
          (unless env (setq env "quotient"))
          (setq beg (og/math-frac--start-of-match)))
        (og/math-frac--region beg end env)))
     ((string-match-p "[[:alnum:]!}]" ch)
      (setq beg (og/math-frac--start-of-match))
      (og/math-frac--region beg end env))
     (t (unless env (setq env "frac"))
        (yas-expand-snippet (yas-lookup-snippet env))
        (yas-abort-snippet)))))
#+END_SRC
**** Easy Split Environments
I wanted to make writing environments like =split= and =align= easier, so that I
wouldn't have to manually add the newline (=\\=) at the end of each line required
to make LaTeX happy.
#+BEGIN_SRC emacs-lisp
(defun og/math-in-env-p (env)
  (when (og/in-math-p)
    (save-excursion
      (if (eq major-mode 'org-mode)
          (org-backward-paragraph)
        (backward-paragraph))
      (forward-line)
      (equal (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position))
             (format "\\begin{%s}" env)))))

(defun og/tex-newline ()
  (interactive)
  (if current-prefix-arg
      (progn
        (insert "\\\\")
        (newline))
    (let ((current-line (buffer-substring-no-properties
                         (line-beginning-position)
                         (line-end-position))))
      (if (equal current-line "\\begin{split}")
          (newline)
        (end-of-line)
        (unless (equal (og/last-n-chars 2) "\\\\")
          (insert " \\\\"))
        (if (save-excursion
              (forward-line)
              (equal (buffer-substring-no-properties
                      (line-beginning-position)
                      (line-end-position))
                     "\\end{split}"))
            (progn
              (newline)
              (when (equal (substring (s-trim current-line) 0 2) "&=")
                (insert "&= ")))
          (forward-line))))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref math-mode
(define-conditional-key og/math-mode-map (kbd "RET") #'og/tex-newline (og/math-in-env-p "split"))
#+END_SRC
**** Convert Inline Math to Equation
Turns an inline math snippet into an equation.
#+BEGIN_SRC emacs-lisp
(defun og/math-inline-to-equation ()
  (interactive)
  (let* ((fr (org-element-context))
         (fr-type (car fr))
         (fr-begin (org-element-property :begin fr))
         (fr-end (org-element-property :end fr))
         (match (buffer-substring-no-properties
                 (+ fr-begin 2)
                 (- fr-end 2)))
         (char (char-to-string (char-after fr-end))))
    (when (eq fr-type 'latex-fragment)
      (delete-region fr-begin (if (string-match "\\.\\|," char)
                                  (1+ fr-end)
                                fr-end))
      (newline)
      (insert "\\begin{equation}\n")
      (insert match)
      (when (string-match "\\.\\|," char) (insert char))
      (save-excursion
        (insert "\n\\end{equation}\n")
        (when (eq (char-after) ? )
          (hungry-delete-forward 0))))))
#+END_SRC
**** Convert Equation to Split
Janky way to turn equation into split. Does idempotence check.
#+BEGIN_SRC emacs-lisp
(defvar og/math-split-delims '(" =" "\\le " "\\ge " "\\sim "))

(defun og/math-make-split ()
  (interactive)
  (let* ((fr (org-element-context))
         (fr-type (car fr))
         (fr-begin (org-element-property :begin fr))
         (fr-end (org-element-property :end fr))
         (match (buffer-substring-no-properties fr-begin fr-end)))
    (when (eq fr-type 'latex-environment)
      (save-excursion
        (goto-char fr-begin)
        (forward-line 1)
        (unless (string-match-p (regexp-quote "split")
                                (buffer-substring-no-properties
                                 (line-beginning-position)
                                 (line-end-position)))
          (insert "\\begin{split}\n")
          (goto-char fr-end)
          (goto-char (line-beginning-position))
          (open-line 1)
          (insert "\\end{split}")
          (goto-char fr-begin)
          (forward-line 2)
          (when (string-match (regexp-opt og/math-split-delims)
                                (buffer-substring-no-properties
                                 (line-beginning-position)
                                 (line-end-position)))
              (goto-char (+ (line-beginning-position) (match-beginning 0)))
            (when (not (equal "&" (char-to-string (char-before))))
              (when (equal " " (char-to-string (char-after)))
                (forward-char))
              (insert "&"))))))))
#+END_SRC
**** Add Float to Marginnote
I often add a margin note then decide to shift it down. However, margin notes
and shifted notes use different link types.
#+BEGIN_SRC emacs-lisp
(defun og/math-make-marginnote-float ()
  (interactive)
  (if (org-in-regexp org-link-bracket-re 1)
      (let* ((remove (list (match-beginning 0) (match-end 0)))
             (description (match-string-no-properties 3))
             (shift-regexp ";[0-9]*ex")
             (shift (if (string-match-p shift-regexp description)
                        (s-replace "ex" "" (nth 1 (split-string description ";")))
                      "0"))
             (element (org-element-context))
             (path (org-element-property :path element)))
        (when (equal path "marginnote")
          (apply 'delete-region remove)
          (insert (format "[[latex-opt:marginnote][%s;0ex]]" (replace-regexp-in-string shift-regexp "" description)))))))
#+END_SRC
**** Check if in commutative diagram
#+BEGIN_SRC emacs-lisp
(defun og/math-in-commutative-diagram ()
  (string-match-p (regexp-quote "tikzcd") (org-element-property :value (org-element-context))))
#+END_SRC
*** Inkscape Figures
This is the mode we will load in Inkscape when we insert math.
#+BEGIN_SRC emacs-lisp
(define-derived-mode inkmath-mode org-mode "Ink" ()
  :after-hook (flyspell-mode -1)
  (quick-math-mode)
  (pretty-math-mode)
  (setq mode-line-format nil)
  (when (= (point) (point-min))
    (funcall-interactively 'forward-char 2)))

(defun og/inkmath-end ()
  (interactive)
  (save-buffer)
  (delete-frame))

(bind-key [remap org-ctrl-c-ctrl-c] #'og/inkmath-end inkmath-mode-map)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.inkmath\\'" . inkmath-mode))
#+END_SRC
I don't want to mark these files as recently visited.
#+BEGIN_SRC emacs-lisp
(after! recentf
  (push ".*inkmath$" recentf-exclude))
#+END_SRC
We need a way to make Inkscape figures from Emacs. The =org-inkscape-figure=
snippet calls this function.
#+BEGIN_SRC emacs-lisp
(defun og/inkscape-figure ()
  (interactive)
  (let ((imgdir (expand-file-name "figures/" default-directory)))
    (unless (file-directory-p imgdir)
      (mkdir imgdir))
    (let ((default-directory imgdir)
          (name (read-string "Figure name: ")))
      (call-process "inkscape-figures" nil 0 nil
                    "create" name)
      (shell-command "i3-msg \"fullscreen\"")
      (shell-command "i3-msg \"fullscreen\"")
      (cl--set-buffer-substring (line-beginning-position) (line-end-position) "")
      (yas-expand-snippet (format "#+name: fig:%s\n #+caption: $2\n #+attr_latex: :vertical-alignment b\n [[file:figures/%s.pdf_tex]]\n$0" name name)))))
      #+END_SRC
* Options
*** Don't Make =<>= Parentheses
There is so much elisp here that forms like =(< 1 2)= mess up the =check-parens=.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-settings
(defun og/angle-bracket-syntax ()
  (interactive)
  (modify-syntax-entry ?\< "w" org-mode-syntax-table)
  (modify-syntax-entry ?\> "w" org-mode-syntax-table))
#+END_SRC
#+OPTIONS: todo:nil
#+PROPERTY: header-args :results silent :tangle gmacs.el
# Local variables:
# eval: (add-hook 'after-save-hook 'og/tangle-gmacs nil t)
# end:
